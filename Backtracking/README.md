# 백트래킹 정리 내용

## 백트래킹(Backtracking) 개요
백트래킹 알고리즘은 1950년대에 처음 등장한 알고리즘으로 문제의 해가 될 수 있는 후보를 찾고, 해가 될 수 있는 후보를 찾고, 해가 될 수 있는 조건을 충족하지 못하는 후보를 제거해나가면서 최종 해를 찾는 기법이다.
<br>

## 백트래킹 개념
백트래킹은 여러 후보해 중 특정 조건을 충족시키는 모든 해를 찾는 알고리즘이다.
<br>
백트래킹이 다루는 문제들은 해가 하나 이상 존재한다.
<br>
해가 둘, 셋, 수백, 수천 개일 수도 있다.
<br>
<br>
예를 들어 탈출로가 2개인 미로 문제는 해가 2개라고 할 수 있는데, 이 두 해를 일컬어 '모든 해'라고 한다.
<br>
미로의 한 지점에서 탈출구로 향하는 경로 속에는 여러 길목이 있는데 이들 각 길목에서 왼쪽으로 갈지 오른쪽으로 갈지 또는 계속 가던 방향으로 갈지의 물음(부분 문제)에 답(부분해)을 구하는 과정을 반복하면서 완성한 것이 탈출로(해)이다.
<br>
<br>
여기에서 부분 문제의 답은 어느 것이든 될 수 있다.
<br>
그 이유는 선택한 방향으로 끝까지 가봐야 '해를 이루는 부분해'가 될지 안될지 알 수 있으니까 이다.
<br>
<br>
게다가 선택한 밯양으로 가다 보면 새로운 길목을 만나게 될 것이고, 그곳에서 다시 여러 가능성을 두고 선택해야 하는 상황이 온다.
<br>
이렇게 **해가 될 수 있는 가능성을 가진 부분해의 조합을 두고 후보해**라고 한다.
<br>
<br>
백트래킹이 다루는 문제들은 대부분 후보해의 수가 굉장히 많다는 특징이 있다.
<br>
이 중에서 해가 될 **조건을 만족시키는 '진짜 해'를 효율적으로 찾는 것이 백트래킹의 목적**이다.
<br>
<br>
Backtrack은 '오던 길을 따라 되돌아 나오다' 라는 뜻을 갖고 있다.
<br>
이 단어의 동명사인 Backtracking은 번역하면 '되돌아 나오기'라는 뜻이 된다.
<br>
<br>
예를 들어 아래 그림과 같은 미로에서 탈출로를 찾아야 한다면 미로가 단순하므로 한눈에 탈출로를 찾아낼 수 있다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/590f461d-316c-4e28-a8df-5c72851bcc35)

<br>

그러냐 여기서는 방금 찾아낸 탈출로를 머릿속에서 지우고 자신이 미로 속에 있다고 가정한다.
<br>
지금 S 지점에 위치해 있으며 탈출구가 있는 G 지점까지 이동해야 한다.
<br>
<br>
길목에 붙인 번호는 길목에서 나뉘는 길들을 구분하기 위해 임의로 매긴 번호이다.
<br>
길을 가다가 이 길목을 만나면 어느 쪽으로 갈 것인지 선택해야 한다.
<br>
이 선택에 대한 경우의 수를 트리로 나타내면 다음과 같다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/11702be4-1ddb-4a9b-be99-f406a6569de3)

<br>
출발점 S를 지나 만나는 새로운 길은 1번과 2번 두 가지이다.
<br>
1번 길 끝에는 더 이상 새로운 길이 나오지 않고, 2번 길에는 3번과 4번으로 갈 수 있는 길목이 나온다.
<br>
4번 길로 가면 막다른 곳이 나오고 3번 길을 따라가면 5번과 6번을 선택할 수 있는 길목이 나온다.
<br>
5번 길에서는 새로운 길이 나오지 않고 6번 길을 따라가면 목표 지점인 탈출구 G를 만날 수 있다.
<br>
<br>
이러한 규칙으로 미로를 탐색하면 탐색 규칙은 다음과 같다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/4b36b0ba-b354-46e2-b694-82f4feb3928e)


<br>

갈림길이 나오면 왼쪽 방향을 먼저 시도한다고 했는데, 두 번째 그림에서 1번 길을 시도 했는데 더 이상 갈 곳이 없으므로 이 후보해는 해가 아니라는 사실을 알 수 있다.
<br>
그레서 세 번째 그링메서 1번 길을 포기하고 오던 길로 되돌아와서(Backrack) 2번 길을 시도한다.
<br>
<br>
같은 일이 다섯 번째, 여섯 번째 그림에서도 나타난다.
<br>
5번 길을 먼저 시도했늗네 더 이상 계속 진행할 수 없어서 뒤로 돌아와 6번 길을 시도한다.
<br>
<br>
이런 과정을 반복한 끝에 여섯 번째 그림과 같이 탈출구를 찾게 된다.
<br>
<br>
드디어 S-2-3-6-G가 이 미로의 탈출로라는 사실을 알아낼 수 있다.
<br>
<br>
이 과정은 깊이 우선 탐색 알고리즘(DFS)과 비슷한 면이 있다.
<br>
깊이 우선 탐색은 모든 노드를 방문하는 것이 목적이고, 백트래킹은 해를 찾는 것이 목적이므로 꼭 모든 노드를 방문할 필요가 없다는 차이점이 있다.
<br>
<br>
백트래킹은 **해를 찾는 비용을 줄이기 위해 방문할 노드의 수를 최소화하는 것이 중요**하다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/864c2159-2191-4502-b01c-892d0b271f88)

<br>

백트래킹이 다루는 문제들은 다양한 후보해를 갖고 있는데 이 후보해들은 부분해로 이루어져 있어 미로 문제와 같이 트리 형태로 표현할 수 있다.
<br>
이러한 후보해 속에서 해를 찾는 과정은 다음과 같다.
1. 해를 찾아가는 과정은 '뿌리'에서 부터 출발 (뿌리도 하나의 부분해)
2. 현재 위치한 부분해에서 선택 가능한 다음 부분해의 목록을 얻음
3. 2단계에서 얻은 부분해들을 하나씩 방문
4. 방문한 부분해가 '해가 될 수 있는 조건'을 만족시키면 그 자리에서 2단계와 3단계를 수행하고, 그렇지 않으면 그 이전 부분해로 돌아 나와 다른 부분해를 시도
5. 최종해를 얻을 때까지 또는 모든 경우의 수를 확인해도 해가 없음을 확인할 때까지 2 ~ 4 단계 반복

<br>

## 미로 탈출로 찾기

### 재귀 호출 기반 백트래킹
앞서 봤던 미로를 트리로 표현하고 이 트리 속의 노드를 옮겨 다니면서 탈출구로 향하는 길을 알아냈다.
<br>
하지만 이 트리는 어디까지나 논리적인 개념이지 물리적인 존재가 아니다.
<br>
<br>
이말은 곧, 복잡한 트리 자료구조 없이도 미로 탈출 알고리즘을 구현할 수 있다는 뜻이다.
<br>
여러 방법으로 구현할 수 있지만, 여기서는 구현이 간편한 재귀 호출을 이용한다.
<br>
먼저 아래와 같은 노드 순회 그림이 있다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b93afc2f-5d52-402e-a739-8228b756ea5b)

<br>
이 그림은 부분해에서 다음 부분해를 시도하는 과정을 나타낸다.
<br>
우리 눈에 보이는 것은 노드 이동 장면이지만 그 뒤에 숨겨진 의미는 '부분해에서 또 다른 부분해를 탐색한다' 이기 때문이다.
<br>
<br>
노드 순회가 '노드 이동 -> 자식 노드 목록 확인 -> 각 자식 노드로 이동'의 반복으로 이루어진다.
<br>
마찬가지로 백트래킹에서 해를 구하는 과정도 마찬가지로 부분해 계산 -> 다음 부분 후보해 목록 확인 -> 각 부분 후보해 계산의 반복으로 이루어진다.
<br>
<br>
그리고 부분해를 구하기 위해 이루어지는 이러한 반복 과정은 자연스럽게 재귀 호출과 어울린다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/0528996d-6117-4599-9b9a-b3668a85ba5b)

<br>
이제 우리는 한 부분해에서 다음 부분 후보해를 시도하는 과정을 재귀 호출로 구현할 수 있다는 사실을 알았다.
<br>
그렇다면 시도한 부분 후보해가 해가 될 수 있는 조건을 충족시키지 못했을 때 수행하는 '되돌아 나오기' 즉 백트래킹 표현 방법을 알아야 한다.
<br>
<br>
백트래킹을 처리해야 하는 경우는 현재 시도 중인 부분 후보해가 해가 될 수 있는 조건을 만족하지 못했을 때와 최종해를 확보한 경우 두 가지이다.
<br>
상위 부분해가 호출한 후보 부분해의 재귀 함수에서 백트래킹을 만나면 그저 함수를 반환하는 것만으로 백트래킹이 이루어진다.
<br>
상위 부분해를 시도 중인 제어 흐름으로 돌아가기 때문이다.
<br>
<br>
제어를 돌려받은 상위 부분해는 나머지 부분 후보해들을 차례대로 시도하고, 모든 부분 후보해에 대해 시도를 마치면 여기서도 함수를 반환하여 자신을 호출한 더 상위의 부분해로 돌아간다.
<br>
<br>
물론 그 상위 부분해, 그다음 상위 부분해에 대해서도 같은 작업을 반복한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/61f7337b-cce7-4302-86a7-57064b630b3b)

<br>

## 미로 탈출 알고리즘의 구현

### 자료구조 정의
알고리즘 구현에 앞서 미로를 표현하는 자료구조를 정의한다.
<br>
알고리즘이 미로 모양이나 크기에 상관없이 동작할 수 있도록 미로 데이터를 담을 수 있는 자료구조를 선택해야 한다.
<br>
그러므로 미로를 표현할 자료구조로 MazeInfo 구조체를 다음과 같이 정의한다.

```
typedef struct tagMazeInfo
{
    int columnSize;  // 너비
    int rowSize;     // 높이
    char** data;     // 동적으로 할당한 2차원 배열을 담기 위한 2차원 포인터
} MazeInfo;
```

미로는 시작점과 탈출구, 길과 벽, 탈출구로 향하는 길 표식으로 이루어진다.
<br>
이들은 각각 다음과 같이 정의한다.

```
#define START    'S'   // 시작점
#define GOAL     'G'   // 탈출구
#define WAY      ' '   // 길
#define WALL     '#'   // 벽
#define MARKED   '+'   // 탈출구로 향하는 길 표식
```

다음을 미로를 기호로 나타낸 예이다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/ce12726f-4a5e-404b-b1ec-6cdf7d34bcfa)

<br>

그리고 미로 안의 위치를 나타내기 위한 자료 구조도 필요한데, 수평 위치 X와 수직 위치를 나타내는 Y를 갖는 구조체를 다음과 같이 정의한다.

```
typedef struct tagPosition
{
    int x;   // 수평 위치
    int y;   // 수직 위치
} Position;
```

### 알고리즘의 구현
미로 탈출 알고리즘은 다음 4단계 과정으로 이루어진다.
1. 시작점 S를 현재 위치로 지정하고 이동 방향을 북으로 설정
2. 현 위치에서 가고자 하는 방향으로 이동 가능한 여부를 확인 (벽과 지나왔던 길은 이동 불가능한 길)
3. 2단계에서 이동 가능한 방향임이 확인되면 그 곳으로 이동하고, 이동이 불가능한 방향이라고 확인되면 방향(북-남-동-서 순서)을 바꿔 다시 2단계 실행, 현 위치에서 북, 남, 동, 서 어떤 방향으로도 이동할 수 없음이 확인되면 이전 위치로 돌아감
4. 출구를 찾거나 미로 내의 모든 길을 방문할 때까지 2 ~ 3단계 반복

2단계를 처리하는 함수는 GetNextStep(), 3단계를 처리하는 함수는 MoveTo() 라고 이름을 붙인다.
<br>
그리고 1단계와 4단계를 처리하는 함수의 이름은 Solve()라고 짓는다.
<br>
<br>
이들의 호출 관계는 대강 Solve() 함수가 시작점 S를 찾아 현 위치를 초기화하고, 다음 위치로 이동하기 위해 MoveTo() 함수를 호출한다.
<br>
MoveTo() 함수는 현 위치를 매개 변수로 GetNextStep() 함수를 호출하여 이동할 위치를 구해 그곳으로 이동하고, 그곳에서도 다시 MoveTo() 함수를 호출하여 새로운 위치로 이동한다.
<br>
<br>
만약 GetNextStep()이 북, 남, 동, 서 어떤 방향으로도 이동할 수 없다고 판정한다면 MoveTo() 함수를 반환하여 이전 위치로 돌아간다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/55ca52a3-aa5d-4641-b5b7-b88f5330e7db)

<br>

Solve(), MoveTo(), GetNextStep() 함수의 원형은 다음과 같다.

```
int Solve(MazeInfo* maze);
int MoveTo(MazeInfo* maze, Position* current, int direction);
int GetNextStep(MazeInfo* maze, Position* current, int direction, Position* next);
```

## 미로 탈출 알고리즘 예제 프로그램
이 프로그램은 미로 데이터를 받도록 구성되어 있다.
<br>
'S', 'G', '#', ' ' 등으로 표시되어 있는 미로 데이터 파일을 입력 받으면 그것을 읽어 들여 Solve() 함수에 매개 변수로 넘긴다.
<br>
미로 데이터를 읽는 함수의 이름은 GetMaze() 이다.















