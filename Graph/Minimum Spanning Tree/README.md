# 최소 신장 트리 정리 내용

## 최소 신장 트리(Minimum Spanning Tree)
최소 신장 트리란 최소 가중치(Weight) 신장 트리 라고도 부른다.
<br>
그래프 내의 모든 정점을 포함하는 트리로, 말 그대로 가중치의 합이 최소가 되는 간선만 남긴 신장 트리가 바로 최소 신장 트리이다.
<br>
<br>
최소 신장 트리는 최소한의 비용으로 트리를 만들어내는 알고리즘이다.
<br>
<br>
최소 신장 트리를 만들어내기 위해 일반적으로 두 가지 기법이 적용된다.
- 프림 알고리즘(Prim's Algorithm)
- 크루스칼 알고리즘(Kruskal's Algorithm)



# 프림 알고리즘(Prim's Algorithm)

프림 알고리즘이란 로버트 프림(Robert C. prim)이 고안한 그래프에서 최소 신장 트리를 만들어 내는 알고리즘을 말한다.
프림 알고리즘은 최소 신장 트리에서 일반적으로 사용되는 두 가지 기법 중 하나이다.
<br>

## 프림 알고리즘을 이용한 최소 신장 트리 구현 과정

프림 알고리즘은 총 4가지 과정을 거치는데, 다음과 같은 과정을 거친다.
1. 그래프와 최소 신장 트리를 준비한다. (이때 최소 신장 트리는 노드가 하나도 없는 상태)
2. 그래프에서 임의의 정점을 시작 정점으로 선태갛여 최소 신장 트리의 뿌리 노드로 삽입
3. 최소 신장 트리에 삽입된 정점들과 이 정점들의 모든 인접 정점 사이에 있는 간선의 가종치 조사 후 간선 중 가장 가중치가 작은 것을 골라 이 간선에 연결된 인접 정점을 최소 신장 트리에 삽입 (새로 삽입되는 정점은 최소 신장 트리에 삽입된 기존 노드와 사이클을 형성해선 안됨)
4. 3번의 과정을 반복하다가 최소 신장 트리가 그래프의 모든 정점을 연결하게 되면 알고리즘 종료


이제 아래 예제는 위 4가지의 과정을 거쳐 그래프를 최소 신장 트리로 만들어내는 과정이다.
<br>
<br>

가장 먼저 아래와 같은 그래프가 존재한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222043638-9991d5d1-1f77-479f-87c8-e5989b4f8b1a.png)


<br>

우선 그래프에서 <b>시작 정점을 정해야</b> 한다. 
<br>
시작 정점은 어느 것을 골라도 상관 없으며, 고른 정점은 시작 정점이면서 동시에 최소 신장 트리의 뿌리 노드가 된다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222044483-e19a8f74-0ee0-4f45-b662-8da1a6e5d7a2.png)



<br>

정점 B에 연결된 간선들을 살펴보면 B-A, B-C, B-F 총 3개가 존재하는 것을 볼 수 있다.
> 가중치의 오름차순 표시
<br>
이 중에서 먼저 가장 가중치가 작은 간선은 B-A(35)이므로 A를 최소 신장 트리에 추가한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222044001-24ff69e9-78e8-4252-925f-b444b34d99b3.png)


<br>

이제 최소 신장 트리에 존재하는 노드는 B와 A로 2개이며, 다시 이들 노드에 연결된 간선들을 찾는다.
<br>
이들 노드에 연결된 간선들은 B-C(126), B-F(150), A-E(247) 로 총 3개이며, 다시 <b>최소 가중치</b>를 가진 간선을 찾는다.
<br>
<br>
최소 가중치는 B-C 간선이므로, C를 최소 신장 트리에 추가한다.
<br>
C가 추가 되면서 최소 신장 트리의 노드는 모두 3개가 되었으며, 다시 조사해야 할 간선도 4개가 된다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222044403-7970cd72-91c5-46a1-a0cd-cda779654df7.png)


<br>

이번에 조사해야 할 간선은 C-D(117), B-F(150), C-G(220), A-E(247)로 최소 가중치 간선은 C-D(117)으로 D를 최소 신장 트리에 추가한다.
> C-F 간선은 빠졌는데, C-F 간선이 B-C-F를 통과하는 사이클을 형성하기 때문이다. B-F, C-F 둘 중 하나를 제외하면 되는데, C-F의 가중치가 B-F보다 더 커서 C-F를 제외함

<br>

![image](https://user-images.githubusercontent.com/87363461/222044802-5cdfec23-7ec8-495a-a36a-d291bd359232.png)

<br>

다시 과정을 반복하면서 최소 가중치를 찾아 조사해야 한다.
<br>
조사할 간선은 3개로, B-F(150), C-G(220), A-E(247) 중 B-F(150) 이므로 F를 최소 신장 트리에 추가한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222044920-0cb2fe8b-2d05-46bf-b180-88259d32531b.png)


<br>

F가 최소 신장 트리에 추가됨으로써 조사 대상 간선에 큰 변화가 생기게 된다.
<br>
<br>
A-E 간선은 가중치가 더 작은 F-E 간선에 의해, 또 C-G 간선 역시 가중치가 더 작은 F-G 간선에 의해 조사 대상에서 제거되었다.
<br>
그리고 F-H 간선이 조사 대상으로 새로 추가된다.
<br>
<br>
다시 새로운 간선을 찾는데, F-E(82), F-H(120), F-G(154) 중 최소 가중치 간선은 F-E(82)이므로 E를 최소 신장 트리에 추가한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222045144-188bacd7-a8f2-480b-8cb3-6006d75c166b.png)


<br>

F-H 간선은 사이클 형성 이슈로 인해 조사 대상에서 제거되고, 이후 조사할 간선은 E-H(98)와 F-G(154) 2개이다.
<br>
더 작은 가중치 값은 E-H(98) 간선으로 최소 신장 트리에 H를 추가한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222045237-ce3af1ee-3c6f-4d9d-927e-ecd5625fa30f.png)


<br>

조사 대상 간선이 F-G(154) 간선 하나만 남았으므로 G를 최소 신장 트리에 추가한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222045335-e8b95b2d-638d-45ee-a9c1-03407223cc41.png)


<br>

이제 마지막으로 조사 대상 간선이 G-I(106) 하나만 남았으므로 정점 I를 최소 신장 트리에 추가한다.
<br>
이것으로 최소 신장 트리 구축이 완성되었다.
<br>

![image](https://user-images.githubusercontent.com/87363461/222045438-7e0d86a1-175d-4731-8b1f-e11b3eb64499.png)


<br>

## 프림 알고리즘의 고려해야 할 문제점
프림 알고리즘의 구현은 간단해 보일 수 있지만, 2가지의 문제를 고려해야 한다.

### 첫 번째로 어떤 자료구조를 최소 신장 트리에 사용할 것인가?
보통 배열, 링크드 리스트, 트리, 그래프 등을 사용할 수 있다.

### 두 번째로 최소 가중치를 골라내는 과정에서 발생하는 성능 문제
조사 대상 간선 중 최소 가중치를 골라내는 작업의 성능 문제가 심각한 문제이다.
<br>
최소 신장 트리에 정점이 하나 추가될 때마다 그 수가 늘어나거나 줄어드는 조사 대상 간선 집합 속에서 찾는 것 때문이다.
<br>
<br>
정점이 새로 추가될 때마다 모든 그래프의 정점을 순회하고, 이 정점들이 최소 신장 트리에 추가되었는지 확인해야 한다.
<br>
또한 최소 신장 트리에 추가된 모든 정점의 간선을 조사해서 최소 가중치를 찾아야 한다.
<br>
<br>
만약 그래프에 정점이 N개 존재한다고 할 경우 정점 추가 작업을 N회, 정점 추가 시 그래프 내 정점 N개를 순회해야 한다.
<br>
즉, N * N회(N^2)의 반복을 처리해야 한다.


<br>


## 크루스칼 알고리즘(Kruskal's Algorithm)
프림 알고리즘은 최소 신장 트리에 연결된 정점들의 주변 정보를 파악하여 최소 신장 트리를 완성해 나간다.
<br>
그 반면 크라수클 알고리즘은 그래프 내 모든 간선의 가중치 정보를 사전에 파악하고 이 정보를 토대로 최소 신장 트리를 구축해 나간다.
<br>
<br>
크루스칼 알고리즘은 다음 순서대로 동작한다.

1. 그래프 내의 모든 간선을 가중치와 오름차순으로 정렬하여 목록을 만든다.
2. 1번 과정에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가한다.<br>단, 이때 추가된 간선으로 인해 최소 신장 트리 내에 사이클이 형성되면 안 된다.

<br>



## 크루스칼 알고리즘의 고려해야 할 문제점

언뜻 보면 크루스칼 알고리즘이 프림 알고리즘보다 더 간결해 보인다.
<br>
하지만 크루스칼 알고리즘에도 구현을 위해 해결해야 할 문제가 있다.
<br>
그것은 바로 **'최소 신장 트리에 생기는 사이클을 어떻게 효율적으로 감지할 것인가?'** 이다.
<br>
<br>
이 문제에 대한 해결책으로 깊이 우선 탐색(DFS)를 생각해 볼 수 있다.
<br>
깊이 우선 탐색을 수행할 때 이미 방문했던 노드를 또 만난다면 사이클이 있다는 뜻이기 때문이다.
<br>
<br>
예를 들어, 다음과 같은 방향성 그래프에서 깊이 우선 탐색을 수행한다고 하자.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/6c354d2b-f087-4fc7-99b2-d072f3b69250)


<br>

먼저 A-B-D를 방문하고 이 정점들을 '방문했음' 으로 표시한다.
<br>
그런데 정점 A로 돌아와서 정점 C를 타고 내려가면 이미 방문한 것으로 표시된 D를 만나게 된다.
<br>
<br>
이때 그래프에 사이클이 존재한다는 사실을 감지할 수 있다.
<br>
이 그래프가 무방향성 그래프라면 깊이 우선 탐색을 통해 A-B-C-D-A 순서로 순회하여 이미 방문한 A를 만남으로써 사이클이 존재한다는 사실을 감지할 수 있다.
<br>


![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/1a6b762d-bb3d-4eac-ae3a-c8c0b900fb07)


<br>
이 알고리즘은 탐색 비용이 커서 아쉬운 알고리즘이다.
<br>
대안으로 사용할 수 있는 사이클 탐지 방법은 집합을 이용하는 것이다.
<br>
<br>
먼저 각 정점별로 각각의 분리 집합을 만들고, 간선으로 연결된 정점들에 대해서는 합집합을 수행한다.
<br>
이때 간선으로 연결한 두 정점이 같은 집합에 속해 있다면 이 연결은 사이클을 이루게 된다.
<br>
<br>
예를 들어 아래 그림과 같이 정점 A와 Dㄹ르 간선으로 연결한다고 가정한다.
<br>
왼쪽 그림에서는 정점 A와 정점 D가 별개의 집합 속에 있기 때문에 사이클을 이루지 않는다.
<br>
하지만 오른쪽 그림에서는 이 두 정점이 같은 집합 속에 있기 때문에 둘을 연결하면 사이클이 생긴다.
<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/c0a1dfb2-6e79-4f57-846d-0af48facdca7)


<br>

## 크루스칼 알고리즘 구현 방법

예를 들어 아래와 같은 그래프가 존재한다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/37d1b103-3c08-4189-b336-2795447f0949)


<br>

우선 그래프의 정점 사이에 있는 모든 간선을 가중치 오름차순으로 정렬해야 한다.
<br>
정렬하면 A-B가 가중치 35로 가장 작고 A-E 가중치가 247로 가장 크다.

```
A - B : 35
E - F : 82
E - H : 98
G - I : 106
C - D : 117
F - H : 120
B - C : 126
B - F : 150
F - G : 154
C - F : 162
C - G : 220
A - E : 247
```

그리고 각 정점별로 분리 집합을 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/3962004f-4820-4165-9ad9-a8d12f0829f3)

<br>

간선을 가중치 순으로 정렬하고 각 정점별로 분리 집합을 만들었다면 모든 준비가 끝났다.
<br>
<br>
이제 가장 작은 가중치를 가진 간선부터 작업을 시작한다.
<br>
가장 작은 중치는 35인 A-B이다.
<br>
정점 A와 B는 별개의 분리 집합 원소이므로 이 둘을 최소 신장 트리에 추가하고 간선으로 연결한다.
<br>
<br>
그리고 분리 집합 {A}와 {B}에 대해 합집항르 수행하여 하나의 분리 집합으로 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/f9247a13-7742-422f-a9e8-a70e55c2ad45)


<br>

두 번째로 작은 가중치를 가진 간선은 E-F(82)이다.
<br>
이 간선 양쪽 끝에 있는 정점도 별개의 분리 집합에 속해 있으므로 최소 신장 트리에 추가할 수 있다.
<br>
E-F를 최소 신장 트리에 추가하고 분리 집합 {E}와 {F}를 합하여 하나의 분리 집합으로 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/fe4906c2-6f97-4ab6-a644-1c7e2d3a2252)


<br>

그 다음 간선은 E-F(98)이므로, E는 {E, F}에, H는 {H}..에 소속되어 있어 서로 별개의 분리 집합 상태이다.
<br>
따라서 최소 신장 트리에 들어갈 조건을 갖췄으므로 간선 E-F를 최소 신장 트리에 추가하고 {E, F}와 {H}에 대해 합집합을 수행한다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/79883533-339d-4c2b-aa71-512d389184e8)


<br>

다음 순서는 G-I(106) 간선으로 G와 I 역시 서로 별개의 분리 집합에 속해 있으므로 최소 신장 트리에 추가할 수 있다.
<br>
간선 G-I를 최소 신장 트리에 입력하고 {G}와 {I}에 대해서는 합집합 연산을 수행해서 {G, I}를 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/b36ad5ba-6235-4ce0-abe3-a2cc95ce4256)


<br>

다음은 간선 F-H(12)인데, 정점 F와 H는 이미 같은 집합에 속해 있다.
<br>
간선 양끝에 있는 정점이 같은 집합에 속해 있다면 이 간선으로 인해 그래프에 **사이클이 형성되어 있다는 뜻**이다.
<br>
실제로 간선 F-H는 E-F-H에 이르는 사이클이 형성되어 있다.
<br>
<br>
따라서 간선 F-H는 무시하고 다음 순위의 간선을 선택한다.
<br>
<br>
다음 순위의 간선은 C-D(117)으로, 이 둘은 서로 다른 집합에 소속되어 있으므로 최소 신장 트리에 간선을 추가한다.
<br>
그리고 두 정점을 하나의 집합으로 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/5b5dc8d0-4594-40e7-84a5-6e806b9c0df9)


<br>

다음은 B-C(126) 간선으로 B와 C는 서로 다른 집합에 속해 있으므로 이 간선을 최소 신장 트리에 추가한다.
<br>
그리고 B가 속한 {A, B}와 C가 속한 {C, D}에 대해 합집합을 수행한다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/146a4857-f5cc-4593-a0a9-4675159d6ac7)


<br>

다음 순위로 B-F(150) 간선으로, B와 F는 서로 다른 집합에 속해 있으므로 최소 신장 트리에 들어갈 수 있는 조건을 갖췄다.
<br>
간선 B-F를 최소 신장 트리에 추가하고 B가 소속된 {A, B, C, D}와 F가 소속된 {E, F, H}에 대해 합집합을 수행한다.

<br>

<![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/34fef1c5-0916-4b6d-85da-5b6b30955c4c)


<br>

마지막으로 F-G(154) 간선으로, F와 G는 서로 다른 집합에 소속되어 있다.
<br>
간선 F-G를 최소 신장 트리에 추가하고 {A, B, C, D, E, F, H}와 {G, I}를 하나로 만들기 위해 합집합을 수행한다.
<br>
<br>
이렇게 되면 모든 정점이 하나의 집합 안에 모여서 최소 신장 트리가 완성된다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/1a782714-67b1-4118-9eb5-4f739f3a26de)


<br>


## 최소 신장 트리 예제

### [예제 코드](https://github.com/JeHeeYu/Algorithm/blob/main/Graph/Minimum%20Spanning%20Tree/minimum_spanning_tree.c)

### 실행 결과

```
Prim's Algorithm
 A : B[35] 
 B : A[35] C[126] F[150] 
 C : B[126] D[117] 
 D : C[117] 
 E : F[82] H[98] 
 F : E[82] B[150] G[154] 
 G : F[154] I[106] 
 H : E[98] 
 I : G[106] 

Kruskal's Algorithm...
A - B : 35
B - A : 35
F - E : 82
E - F : 82
H - E : 98
E - H : 98
G - I : 106
I - G : 106
D - C : 117
C - D : 117
F - H : 120
H - F : 120
B - C : 126
C - B : 126
B - F : 150
F - B : 150
F - G : 154
G - F : 154
C - F : 162
F - C : 162
G - C : 220
C - G : 220
A - E : 247
E - A : 247
 A : B[35] 
 B : A[35] C[126] F[150] 
 C : D[117] B[126] 
 D : C[117] 
 E : F[82] H[98] 
 F : E[82] B[150] G[154] 
 G : I[106] F[154] 
 H : E[98] 
 I : G[106]
```
