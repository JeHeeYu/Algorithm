## 그래프(Graph) 알고리즘
그래프 알고리즘이란 17세기에 고안된 자료구조로, 원래는 수학 분야에서 만들어졌지만, 현재는 전반적인 분야에서 사용 중인 알고리즘이다.
<br>
그래프는 그래프 형태의 자료구조로 표현한 문제를 해결하는 것에 매우 다양한 알고리즘들이 존재한다.
<br>
<br>
그래프는 정점(Vertex)의 모음과 이 정점을 잇는 간선(Edge)의 모음이 결합한 구조로 볼 수 있다.
<br>
정확하게는 정점의 관계를 표현하는 조직도라고 볼 수 있으며, 아래와 같이 정의할 수 있다.
```
V : 정점의 집합
E : 간선의 집합
G : 그래프
G = (V, E)
```

![캡처](https://user-images.githubusercontent.com/87363461/207198518-7f8b097a-cdc7-40e3-a896-3468681c7d9c.PNG)

<br>

간선으로 연결된 두 정점을  가리켜 서로 <b>인접(Adjacent)</b> 또는 <b>이웃 관계</b>에 있다고 말한다.
<br>
위 그림에서 그래프 구조를 보면, (A, B), (A, D), (A, E), (B, C), (C, D)가 서로 이웃 관계이다.
<br>
<br>
이처럼 간선을 통해 서로 이웃이 된 각 정점은 그래프 안에서 길을 만들기도 한다.
<br>
예를 들어 위 그래프의 정점 A에서 정점 C까지는 A, B, C가 하나의 경로(Path)를 이루고 있으며, A, D, C가 또 하나의 경로를 형성한다.
<br>
<br>
길이는 정점과 정점 사이에 있는 간선의 수로 정의된다.
<br>
여기서 경로 A, B, C 사이에는 간선이 (A, B)와 (B, C) 2개가 있으므로 길이는 2가 된다.
<br>
<br>
만약 어느 경로가 정점 하나를 두 번 이상 거치도록 되어 있다면 그 경로는 사이클(Cycle)이라고 한다.
<br>
예를 들어 아래 그래프에서 A, B, C, D, A에 이르는 굵은 선으로 표시된 경로가 사이클이다.
<br>
또한 사이클은 트리 구조에서 볼 수 없는 특징 중 하나이다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207199059-ca5e95a9-5186-47da-9780-387399dad083.PNG)

<br>

간선이 이웃을 만들고 경로를 만들며 사이클을 형성하는데, 간선은 그래프의 성격 자체를 정의하기도 한다.
<br>
바로 간선의 방향성에 따라 성격이 정의된다.

<ul>
  <li>방향성 그래프(Directed Graph) : 간선에 방향성이 있는 그래프</li>
  <li>무방향성 그래프(Undirected Graph) : 간선에 방향이 없는 그래프</li>
</ul>

![캡처](https://user-images.githubusercontent.com/87363461/207199314-350ee96b-c619-4e87-9392-ed3b46da56bb.PNG)

<br>

그래프에서 연결성(Connectivity)라는 개념이 있는데, 말 그대로 연결성에 따른 특징을 말한다.

<ul>
  <li>무방향성 그래프 내의 <b>두 정점 사이에 경로가 존재하면 이 두 정점이 연결되어 있다고 함</b></li>
  <li>그래프 내의 각 정점이 다른 <b>모든 정점과 연결되어 있다면 이 그래프는 연결되어 있다고 함</b></li>
</ul>

## 그래프 표현 방법
그래프는 정점 집합과 간선 집합의 결합이기 때문에 이를 표현하는 문제는 정점의 집합과 간선의 집합 표현 문제로 볼 수 있다.
<br>
정점의 집합은 배열, 링크드 리스트 등 어떤 구조를 사용해도 상관 없지만, 문제는 간선의 집합을 표현하는 방법이다.
<br>
<br>
정점 사이의 인접 관계를 나타내는 방법으로는 크게 두 가지가 있다.

<ol>
  <li>인접 행렬(Adjacency Matrix) : 행렬을 이용하여 정점 사이의 인접 관계를 표현</li>
  <li>인접 리스트(Adjacency List) : 리스트를 이용하여 정점 사이의 인접 관계를 표현</li>
</ol>

## 인접 행렬(Adjacency Matrix)
인접 행렬은 말 그대로 정점끼리의 인접 관계를 나타내는 행렬 구조를 말한다.
<br>
인접 행렬의 내용은 간단하다. 그래프의 정점 수를 N이라고 했을 때 N X N 크기의 행렬을 만든다.

<ol>
  <li>그래프의 정점 수를 N이라고 했을 때 N * N 크기의 행렬을 생성</li>
  <li>한 정점과 또 다른 정점이 인접해 있는지 확인 (즉, 정점 사이에 간선이 존재하는 경우)</li>
  <li>행렬의 각 원소들을 1로 표시한 후, 인접해 있지 않은 경우는 0으로 표시</li>
</ol>

### 무방향성 그래프
인접 행렬의 예로, 먼저 아래와 같은 그래프 구조가 있다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207201136-7e185552-6834-4fc0-9724-cef60f514fff.PNG)

<br>

이 그래프의 정점 1은 나머지 정점인 2, 3, 4, 5와 모두 인접해 있다.
<br>
그러므로 (1, 2), (1, 3), (1, 4), (1, 5)는 모두 값은 1이다.
<br>
또한 정점2는 정점 1, 3, 5와 이웃해 있으므로 (2, 1), (2, 3), (2, 5)도 모두 1이고, 나머지 정점도 동일하게 적용된다.
<br>
<br>
나머지 (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)는 자기 자신과 인접 관계를 형성할 수 없으므로 0이다.
<br>
<br>
위 그래프 구조를 인접 행렬 구조로 표시한 행렬 구조가 아래 행렬이다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/207201658-99b26071-f1ff-4cab-bded-4c0ee57dff0d.PNG)

<br>

이 행렬에서 동일 정점인 (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)를 기준으로, 행렬을 둘로 나눌 수 있다.
<br>
그러면 인접 행렬이 주 대각선을 기준으로 대칭을 이루는 것을 볼 수 있는데, 중요한 점은 무방향성 그래프의 인접 행렬은 이처럼 주 대각선을 기준으로 대칭을 이루는 것이다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207201932-a2bf1d6a-bfd9-4e0e-ba02-d1f29ea8bf83.PNG)

<br>

### 방향성 그래프
다시 방향성 그래프는 어떻게 되는지 보자.
<br>
<br>
만약 아래와 같은 방향성 그래프가 있다고 한다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/207202156-5f563b28-3d93-4c8d-b1a3-f85594015b7a.PNG)

<br>

무방향성 그래프에서는 정점 Å가 정점 B와 이웃해 있으면, 정점 B도 Å와 이웃한다고 할 수 있지만, 방향성 그래프는 다르다.
<br>
방향성 그래프에서의 정점은 <b>자신이 직접 간선을 통해 가리키고 있는 정점에 대해서만 인접해 있다고 표현</b>한다.
<br>
<br>
이 그래프에서는 정점1은 2, 3, 4, 5에 인접하지만, 정점 3, 5는 인접한 정점이 없다.


## 인접 리스트(Adjacency List)
인접 리스트는 그래프 내 각 정점의 인접 관계를 표현하는 리스트이다.
<br>
즉, 각 정점이 자신과 인접한 모든 정점의 목록을 리스트로 관리하도록 하는 방법을 말한다.
<br>
<br>
인접 리스트를 만드는 방법은 간단한데, 먼저 예로 보면 아래와 같은 그래프가 있다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207205761-8e592e47-6841-4545-99e4-88843294a8b5.PNG)

<br>

이 그래프에서 모든 정점을 늘어놓고, 각 정점의 인접 정점을 표로 나열한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207205865-0e7f6dab-69eb-40da-afed-ef903335a1d8.PNG)

<br>

그 다음, 인접 정점들끼리 리스트로 연결한 후 이를 각 정점에 연결하면 아래와 같은 리스트가 만들어진다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/207205961-bd5cea0a-90c0-4ae0-a816-d9b55a6e51f1.PNG)

<br>

## 인접 행렬과 인접 리스트 비교
인접 행렬과 인접 리스트 중 뭐가 더 좋다는 없지만, 각각의 장단점이 존재한다.

### 인접 행렬
장점 : 정점 간의 인접 여부를 빠르게 확인할 수 있음
<br>
단점 : 인접 관계를 행렬 형태로 저장하기 위해 사용하는 메모리 양이 정점의 크기 * N ^ 2만큼 커짐

### 인접 리스트
장점 : 정점과 간선의 삽입이 빠르고 인접 관계를 표시하는 리스트에 사용되는 메모리 양이 적음
단점 : 정점 간의 인접 여부를 알아내기 위해 인접 리스트를 타고 순차 탐색을 해야 함

<br>
<br>
이렇게 각각의 장단점이 존재하며, 어느 자료구조를 사용할 지는 프로그램의 목적에 따라 결정하는 것이 좋다.
<br>
<br>
예를 들어, 그래프 내의 정점 수가 많지 않거나 정점끼리의 인접 여부를 빠르게 알아내야 한다면 인접 행렬을,
<br>
정점과 간선의 입력이 빈번하게 이루어지며 메모리 효율을 우선시 한다면 인접 리스트가 효율적이다.
<br>
<br>
또한 구현의 용이성으로 볼 때 인접 행렬은 배열을, 인접 리스트는 링크드 리스트를 사용하므로 구현의 용이성은 인접 행렬이 더 좋다고 할 수 있다.

## 인접 리스트 구현 방법
인접 행렬은 2차원 배열 하나로 표현할 수 있지만, 인접 리스트는 정점, 간선, 그리고 이 두가지 집합을 쥐어야 하는 그래프 구조체 총 3개의 구조체가 필요하다.
<br>
<br>
먼저 정점 구조체를 보면, 다음 구조체와 같이 표현한다.
<br>
```
typedef struct _Vertex
{
    int data;
    int visited;
    int index;
    
    struct _Vertex* next;
    struct _Edge* adjacencyList;
} Vertex;
```
각 구조체 필드에 대한 내용은 다음과 같다.

<ul>
  <li>data : 데이터를 담는 필드</li>
  <li>visited : 그래프 순회 알고리즘에서 사용할 필드로, 방문 여부를 나타냄</li>
  <li>index : 정점의 인덱스를 나타내는데, 그래프의 첫 번째 정점은 0, 두 번째 정점은 1 ... 식으로 증가</li>
  <li>next : 다음 정점을 가리키는 포인터</li>
  <li>adjacencyList : 인접 정점의 목록에 대한 포인터</li>
</ul>

다음은 간선 구조체로, 다음 구조체와 같이 표현한다.
```
typedef struct _Edge
{
    int weight;
    struct _Edge* next;
    Vertex* from;
    Vertex* target;
} Edge;
```
각 구조체 필드에 대한 내용은 다음과 같다.

<ul>
  <li>weight : 필드의 간선의 가중치를 나타냄</li>
  <li>next : 다음 간선을 가리키는 포인터</li>
  <li>from : 간선의 시작 정점</li>
  <li>target : 간선의 끝 정점</li>
</ul>

마지막 구조체로, 그래프의 구조체를 나타낸다.
```
typedef struct _Graph
{
    Vertex* vertices;
    int vertexCount;
} Graph;
```
각 구조체 필드에 대한 내용은 다음과 같다.

<ul>
  <li>vertices : 정점 목록에 대한 포인터</li>
  <li>vertexCount : 정점 수를 나타내는 </li>
</ul>
