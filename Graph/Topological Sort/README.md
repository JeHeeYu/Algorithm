## 위상 정렬(Topological Sort)
위상 정렬이란 <b>순서가 정해져있는 작업을 차례로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘</b>이다.
<br>
<br>
먼저 위상의 뜻을 보면 '어떤 사물이 다른 사물과의 관계 속에서 가지는 위치나 양상' 을 말하는데, 사물을 정점으로 바꾸면 그래프에서 사용하는 용어가 된다.
<br>
즉 '어떤 정점이 다른 정점과의 관계 속에서 가지는 위치' 를 말한다.
<br>
<br>
이 말은 그래프 내 서로 인접한 정점 사이의 관계에 '위치'라는 속성이 존재한다는 의미이다.
<br>
이 위치는 간선 방향에 의해 결정되는데, 간선을 뻗어내는 정점이 앞이 되고, 간선을 받아들이는 정점이 뒤가 된다.
<br>
<br>
이 간선의 방향들을 정렬하는 알고리즘이 위상 정렬 알고리즘이다.
<br>


## DAG(Directed Acyclic Graph)
DAG란 위상 정렬을 하기 위해 지켜져야 할 조건이 지켜진 그래프를 말한다.
<br>
DAG 조건, 즉 위상 정렬을 하기 위해 지켜져야 할 조건은 다음 2가지이다.
<ul>
<li>그래프에 방향성이 있어야 함</li>
<li>그래플 내에 사이클이 없어야 함</li>
</ul>

이러한 DAG의 예가 바로 아래 그래프이다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208606822-f23d6d8e-edd7-4e1e-9c38-0aa02df61ed6.PNG)

<br>

## 위상 정렬 동작 방식
위상 정렬 동작 방식을 이해하기 위해 진입 간선과 진출 간선의 의미를 알아야 한다.
<br>
진입 간선과 진출 간선은 간선의 방향성에 의해서 결정되는데, 각각 들어오는 입력, 나가는 출력의 의미이다.
<ul>
<li>진입 간선(Incoming Edge) : 정점으로 들어가는 진입 간선</li>
<li>진출 간선(Outgoing Edge) : 정점에서 나가는 진출 간선</li>
</ul>

아래 그림이 진입 간선과 진출 간선의 예시 그림이다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208607425-d324b65c-4237-4754-98c4-8913d99d4a8e.PNG)

<br>

이렇게 위상 정렬의 동작도 이러한 진입 간선과 진출 간선을 제거해 가면서 위상 정렬이 완성되는 것이다.
<br>
위상 진입 간선과 진출 간선의 의미를 알았으니 위상 정렬의 동작을 이해할 수 있는데, 위상 정렬은 다음과 같은 과정으로 이루어진다.

<ol>
<li>리스트를 준비</li>
<li>그래프에서 진입 간선이 없는 정점을 리스트에 추가하고 해당 정점 자신과 진출 간선 제거</li>
<li>모든 정점에 대해 2번 과정을 반복하고 그래프 내에 정점이 남아 있지 않으면 정렬 종료</li>
<li>리스트에 위상 정렬된 그래프가 저장되며 이 리스트 확인</li>
</ol>

아래 과정은 위 과정을 그림으로 표현한 예시이다.
<br>
<br>

먼저 아래와 같은 그래프에서 위상 정렬을 할 예정이며, 리스트는 빈 상태이다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/208606822-f23d6d8e-edd7-4e1e-9c38-0aa02df61ed6.PNG)

<br>

1단계의 리스트를 준비 했으니 2단계를 수행해야 한다.
<br>
진입 간선이 없는 정점은 A와 B 2개가 있으며, 둘 중 어디서 시작해도 상관 없지만, 이 에제에서는 B에서 시작한다.
<br>
B를 리스트에 추가하고 B와 진출 간선 모두 삭제한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208608770-d33f7a39-86c0-4486-ab72-bb12420767e9.PNG)

<br>

B를 제거하고 난 후 진입 간선이 없는 A 정점과 E 정점이 남았고, 다시 정점 E를 선택한다.
<br>
정점 E를 리스트에 추가하고 정점 E와 그의 진출 간선을 모두 제거한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208609159-fc037df3-e61b-4fec-9b3a-01f61eb7622a.PNG)

<br>

이제 남은 진입 간선이 없는 정점은 A 하나 뿐이므로 A를 리스트에 추가하고 A와 진출 간선을 모두 제거한다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/208609331-00aefc44-2cc3-4fe3-b5e0-aa37969e1e9d.PNG)

<br>

다시 A 이후 정점은 정점 C와 D가 남았으나 D를 먼저 제거한다.
<br>
정점 D를 리스트에 추가하고 관련 진출 간선들을 제거한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208609578-7c1d888a-3af1-4bd0-aacf-597d4be89dc8.PNG)

<br>

이제 진입 간선이 없는 정점은 C와 G 정점이 있는데 G를 먼저 제거하고 관련된 진출 간선을 제거, 이후 리스트에 G를 추가한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208610006-58f87827-9173-4ce4-994c-52db24c3f2cf.PNG)

<br>

진입 간선이 남지 않은 정점은 C 정점 하나로, 리스트에 이 정점을 추가하고 진출 간선과 함께 제거한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208610168-df4f96c0-8e3f-4402-8397-778c37411e77.PNG)

<br>

그 다음음 정점은 다시 F 정점으로 리스트에 이 정점을 추가하고 진출 간선과 함께 제거한다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/208610296-49c18be3-1485-4fcd-a862-99e2ede65958.PNG)

<br>

마지막으로 정점 H만 남았으니, 이 정점을 리스트에 추가하면 위상 정렬이 완성된다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/208610437-6cc9fcd7-2adf-4de4-809a-9ea29a111fe7.PNG)

<br>

## DFS를 이용한 위상 정렬 알고리즘
위상 정렬은 DFS를 이용하여 풀 수 있는 대표적인 알고리즘 중 하나이다.
<br>
DFS를 이용하여 위상 정렬을 하는 과정은 다음과 같다.

<ol>
<li>리스트를 준비</li>
<li>그래프에서 진입 간선이 없는 정점에 대해 DFS를 수행하고, 탐색 중 더 이상 옮겨갈 수 있는 인접 정점이 없는 정점을 만나면 이 정점을 리스트의 새로운 헤드로 입력</li>
<li>과정2를 반복하다가 더 이상 방문할 정점이 없는 경우 DFS 탐색 종료</li>
<li>리스트에 위상 정렬된 그래프가 저장되며 이 리스트 확인</li>
</ol>

먼저 아래와 같은 그래프에서 위상 정렬을 할 예정이며, 리스트는 빈 상태이다.

<br>

![캡처](https://user-images.githubusercontent.com/87363461/208606822-f23d6d8e-edd7-4e1e-9c38-0aa02df61ed6.PNG)

<br>

이후 진입 간선이 없는 정점을 확인하면 정점 A와 B가 있는데 정점 A에서부터 시작한다.
<br>
A - C - F - H 정점을 각각 타고 그래프 안쪽으로 탐색하면 정점 H를 만난다.
<br>
<br>
H 정점에서 옮겨갈 수 있는 인접 정점이 더 이상 없으므로 H를 리스트의 <b>헤드</b>로 삽입한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208611449-04c5ae96-7261-475e-bf2b-7927e468fa93.PNG)

<br>

이후 H 정점에서 뒤로 돌아오면 F 정점을 만난다.
<br>
정점 F의 유일한 인접 정점은 H 정점이었으나 H 정점은 앞에서 방문했으므로 현재는 더 이상 방문할 정점이 없다.
<br>
<br>
그래서 F 정점을 리스트의 헤드로 삽입하고 다시 뒤로 돌아간다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208613114-ebfaba52-4a50-4c3e-96f3-ae39523cabc6.PNG)

<br>

이번은 C 정점으로 유일한 인접 정점이 F 정점이었으나 이미 방문한 정점으로 지금은 인접 정점이 없다.
<br>
C 정점을 리스트의 헤드로 추가하고 다시 뒤로 돌아간다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208613264-009933a4-50df-418c-9b16-5ad9617ca591.PNG)

<br>

A 정점의 차례인데, A 정점의 인접 정점은 C 정점과 D 정점이나 C 정점은 이미 방문하여 D 정점을 방문한다.
<br>
이후 D 정점을 타고 들어가면 D 정점을 거쳐 G 정점에 도착한다.
<br>
<br>
G 정점에서 확인 시 유일한 정점이었던 H 정점은 이미 방문한 정점으로 리스트에 추가되어 있다.
<br>
따라서 G 정점은 방문할 수 있는 인접 정점이 없으므로 G 정점을 리스트의 헤드로 추가하고 다시 뒤로 돌아간다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208614032-c015c64a-1e04-4064-b3cc-e808fefe6a41.PNG)

<br>

뒤로 돌아온 D 정점 역시 인접 정점이 없고, 원래 인접 정점으로 F와 G가 있었는데 둘 다 이미 방문한 상태이다.
<br>
따라서 D 정점을 리스트의 헤드로 삽입한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208614332-673bc459-f098-4be5-b565-af897faa0bf4.PNG)

<br>

다시 돌아와 A 정점인데 A 정점도 방문할 인접 정점이 없으므로 리스트의 헤드에 삽입한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208614426-bc2e94cb-ee4e-4a50-91a8-489537d6d0bf.PNG)

<br>

아래로 내려와 B 정점을 타고 그래프 안으로 들어갈 차례이다.
<br>
B의 인접 정점인 C 정점과 E 정점이 있는데 C 정점은 이미 방문한 정점인 E 정점을 방문한다.
<br>
<br>
그리고 E 정점의 유일한 인접 정점인 G 정점은 이미 방문한 정점으로, E 정점은 다른 인접한 정점이 없다.
<br>
따라서 E 정점을 리스트의 헤드로 삽입하고 다시 뒤로 되돌아간다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208614686-f0ea54e5-3159-456b-9c47-39fd7158d0ad.PNG)

<br>

마지막으로 B 정점 하나만 남았는데 더 이상 방문할 수 있는 인접 정점이 없으므로 B 정점을 리스트의 헤드로 삽입한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/208614822-0716fa9d-ef82-4436-8152-21662e73bd85.PNG)

<br>

이것으로 DFS를 이용한 위상 정렬이 완성되었다.

### [예제 코드](https://github.com/JeHeeYu/Algorithm/blob/main/Graph/Topological%20Sort/Topological_DFS.c)

### 실행 결과
```
H
F
C
G
D
A
E
B
Toplogical Sort Result : B E A D G C F H
```
