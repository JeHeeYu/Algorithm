# 크루스칼 알고리즘 정리 내용

## 크루스칼 알고리즘(Kruskal's Algorithm)
프림 알고리즘은 최소 신장 트리에 연결된 정점들의 주변 정보를 파악하여 최소 신장 트리를 완성해 나간다.
<br>
그 반면 크라수클 알고리즘은 그래프 내 모든 간선의 가중치 정보를 사전에 파악하고 이 정보를 토대로 최소 신장 트리를 구축해 나간다.
<br>
<br>
크루스칼 알고리즘은 다음 순서대로 동작한다.

1. 그래프 내의 모든 간선을 가중치와 오름차순으로 정렬하여 목록을 만든다.
2. 1번 과정에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소 신장 트리에 추가한다.<br>단, 이때 추가된 간선으로 인해 최소 신장 트리 내에 사이클이 형성되면 안 된다.

<br>



## 크루스칼 알고리즘의 고려해야 할 문제점

언뜻 보면 크루스칼 알고리즘이 프림 알고리즘보다 더 간결해 보인다.
<br>
하지만 크루스칼 알고리즘에도 구현을 위해 해결해야 할 문제가 있다.
<br>
그것은 바로 **'최소 신장 트리에 생기는 사이클을 어떻게 효율적으로 감지할 것인가?'** 이다.
<br>
<br>
이 문제에 대한 해결책으로 깊이 우선 탐색(DFS)를 생각해 볼 수 있다.
<br>
깊이 우선 탐색을 수행할 때 이미 방문했던 노드를 또 만난다면 사이클이 있다는 뜻이기 때문이다.
<br>
<br>
예를 들어, 다음과 같은 방향성 그래프에서 깊이 우선 탐색을 수행한다고 하자.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/6c354d2b-f087-4fc7-99b2-d072f3b69250)


<br>

먼저 A-B-D를 방문하고 이 정점들을 '방문했음' 으로 표시한다.
<br>
그런데 정점 A로 돌아와서 정점 C를 타고 내려가면 이미 방문한 것으로 표시된 D를 만나게 된다.
<br>
<br>
이때 그래프에 사이클이 존재한다는 사실을 감지할 수 있다.
<br>
이 그래프가 무방향성 그래프라면 깊이 우선 탐색을 통해 A-B-C-D-A 순서로 순회하여 이미 방문한 A를 만남으로써 사이클이 존재한다는 사실을 감지할 수 있다.
<br>


![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/1a6b762d-bb3d-4eac-ae3a-c8c0b900fb07)


<br>
이 알고리즘은 탐색 비용이 커서 아쉬운 알고리즘이다.
<br>
대안으로 사용할 수 있는 사이클 탐지 방법은 집합을 이용하는 것이다.
<br>
<br>
먼저 각 정점별로 각각의 분리 집합을 만들고, 간선으로 연결된 정점들에 대해서는 합집합을 수행한다.
<br>
이때 간선으로 연결한 두 정점이 같은 집합에 속해 있다면 이 연결은 사이클을 이루게 된다.
<br>
<br>
예를 들어 아래 그림과 같이 정점 A와 Dㄹ르 간선으로 연결한다고 가정한다.
<br>
왼쪽 그림에서는 정점 A와 정점 D가 별개의 집합 속에 있기 때문에 사이클을 이루지 않는다.
<br>
하지만 오른쪽 그림에서는 이 두 정점이 같은 집합 속에 있기 때문에 둘을 연결하면 사이클이 생긴다.
<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/c0a1dfb2-6e79-4f57-846d-0af48facdca7)


<br>

## 크루스칼 알고리즘 구현 방법

예를 들어 아래와 같은 그래프가 존재한다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/37d1b103-3c08-4189-b336-2795447f0949)


<br>

우선 그래프의 정점 사이에 있는 모든 간선을 가중치 오름차순으로 정렬해야 한다.
<br>
정렬하면 A-B가 가중치 35로 가장 작고 A-E 가중치가 247로 가장 크다.

```
A - B : 35
E - F : 82
E - H : 98
G - I : 106
C - D : 117
F - H : 120
B - C : 126
B - F : 150
F - G : 154
C - F : 162
C - G : 220
A - E : 247
```

그리고 각 정점별로 분리 집합을 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/3962004f-4820-4165-9ad9-a8d12f0829f3)

<br>

간선을 가중치 순으로 정렬하고 각 정점별로 분리 집합을 만들었다면 모든 준비가 끝났다.
<br>
<br>
이제 가장 작은 가중치를 가진 간선부터 작업을 시작한다.
<br>
가장 작은 중치는 35인 A-B이다.
<br>
정점 A와 B는 별개의 분리 집합 원소이므로 이 둘을 최소 신장 트리에 추가하고 간선으로 연결한다.
<br>
<br>
그리고 분리 집합 {A}와 {B}에 대해 합집항르 수행하여 하나의 분리 집합으로 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/f9247a13-7742-422f-a9e8-a70e55c2ad45)


<br>

두 번째로 작은 가중치를 가진 간선은 E-F(82)이다.
<br>
이 간선 양쪽 끝에 있는 정점도 별개의 분리 집합에 속해 있으므로 최소 신장 트리에 추가할 수 있다.
<br>
E-F를 최소 신장 트리에 추가하고 분리 집합 {E}와 {F}를 합하여 하나의 분리 집합으로 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/fe4906c2-6f97-4ab6-a644-1c7e2d3a2252)


<br>

그 다음 간선은 E-F(98)이므로, E는 {E, F}에, H는 {H}..에 소속되어 있어 서로 별개의 분리 집합 상태이다.
<br>
따라서 최소 신장 트리에 들어갈 조건을 갖췄으므로 간선 E-F를 최소 신장 트리에 추가하고 {E, F}와 {H}에 대해 합집합을 수행한다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/79883533-339d-4c2b-aa71-512d389184e8)


<br>

다음 순서는 G-I(106) 간선으로 G와 I 역시 서로 별개의 분리 집합에 속해 있으므로 최소 신장 트리에 추가할 수 있다.
<br>
간선 G-I를 최소 신장 트리에 입력하고 {G}와 {I}에 대해서는 합집합 연산을 수행해서 {G, I}를 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/b36ad5ba-6235-4ce0-abe3-a2cc95ce4256)


<br>

다음은 간선 F-H(12)인데, 정점 F와 H는 이미 같은 집합에 속해 있다.
<br>
간선 양끝에 있는 정점이 같은 집합에 속해 있다면 이 간선으로 인해 그래프에 **사이클이 형성되어 있다는 뜻**이다.
<br>
실제로 간선 F-H는 E-F-H에 이르는 사이클이 형성되어 있다.
<br>
<br>
따라서 간선 F-H는 무시하고 다음 순위의 간선을 선택한다.
<br>
<br>
다음 순위의 간선은 C-D(117)으로, 이 둘은 서로 다른 집합에 소속되어 있으므로 최소 신장 트리에 간선을 추가한다.
<br>
그리고 두 정점을 하나의 집합으로 만든다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/5b5dc8d0-4594-40e7-84a5-6e806b9c0df9)


<br>

다음은 B-C(126) 간선으로 B와 C는 서로 다른 집합에 속해 있으므로 이 간선을 최소 신장 트리에 추가한다.
<br>
그리고 B가 속한 {A, B}와 C가 속한 {C, D}에 대해 합집합을 수행한다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/146a4857-f5cc-4593-a0a9-4675159d6ac7)


<br>

다음 순위로 B-F(150) 간선으로, B와 F는 서로 다른 집합에 속해 있으므로 최소 신장 트리에 들어갈 수 있는 조건을 갖췄다.
<br>
간선 B-F를 최소 신장 트리에 추가하고 B가 소속된 {A, B, C, D}와 F가 소속된 {E, F, H}에 대해 합집합을 수행한다.

<br>

<![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/34fef1c5-0916-4b6d-85da-5b6b30955c4c)


<br>

마지막으로 F-G(154) 간선으로, F와 G는 서로 다른 집합에 소속되어 있다.
<br>
간선 F-G를 최소 신장 트리에 추가하고 {A, B, C, D, E, F, H}와 {G, I}를 하나로 만들기 위해 합집합을 수행한다.
<br>
<br>
이렇게 되면 모든 정점이 하나의 집합 안에 모여서 최소 신장 트리가 완성된다.

<br>

![image](https://github.com/JeHeeYu/Algorithm/assets/87363461/1a782714-67b1-4118-9eb5-4f739f3a26de)


<br>























