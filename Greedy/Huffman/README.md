## 허프만 코딩(Huffman Coding)
음악 저장 파일 포맷인 mp3와 이미지 저장 파일 포맷인 JPEG의 공통점은 허프만 코딩을 이용하는 압축 데이터 포맷이라는 점이다.
<br>
<br>
허프만 코딩은 1950년경 데이비드 허프만(David A Huffman)이 MIT 박사과정일 때 만든 알고리즘이다.
<br>
허프만은 로버트 파노 교수의 정보 이론 수업을 듣고 있는데, 시험 과 리포트를 선택해야 할 때 리포트를 선택했고, 교수로부터 내려온 리포트의 주제는 '가장 효울적인 이진 코드 기법을 고안하라' 였다.
<br>
<br>
허프만은 리포트를 제출했고, 그 리포트는 스승인 로버트 파노 교수의 샤논-파도 코딩보다 더 우수한 것으로 드러났고, 전 세게에서 가장 유명한 압축 알고리즘 중 하나가 되었다.
<br>
<br>
하프만 코딩을 알기 전에 먼저 접두어 코드(Prefix Code)라는 것을 알아야 한다.

<br>

## 고정 길이 코드와 접두어 코드
고정 길이 코드(Fixed Length Code)란 말 그대로 모든 코드의 길이가 똑같은 값을 갖는 코드 체계를 말한다.
<br>
자주 사용하는 ASCII가 대표적인 예인데, 이 코드 집합의 모든 코드는 8bit 길이를 가진다.
<br>
고정 길이 코드의 최대 장정믄 다루기 쉽다는 데 있다.
<br>
<br>
ASCII로 문자열을 표현하고 싶으면 8bit 길이의 데이터를 연속해서 이어 붙이면 되고 반대로 문자열의 각 요소를 알고 싶으면 8bit 단위로 끊어 읽으면 된다.
<br>
<br>
예를 들어 비트로 표시된 ASCII 코드 문자열 01100001011000100110001101100100을 확인하면 아래와 같다.
<br>
이 문자열을 8bit씩 쪼개고, 각 조각을 코드 집합에 정의된 값으로 표시한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b2360bfb-7d76-4b4a-b095-10dfa421a772)


<br>

이렇게 해서 'abcd'를 나타내는 코드임을 쉽게 알 수 있다.
<br>
<br>
고정 길이 코드가 이처럼 연산의 편의를 위한 것이라면 가변 길이 코드(Variable Length Code)는 저장 공간 절약을 위해 사용된다.
<br>
가변 길이 코드는 저장 공간을 절약한다는 장점도 있지만 데이터 처리가 상당히 번거롭다는 단점도 있다.
<br>
<br>
접두어 코드(Prifix Code)는 가변 길이 코드의 한 종류로 접두어 코드는 무접두어 코드(Prefix Free Code) 라고 불리기도 하는데, 이 분야에서는 그냥 접두어 코드라고 부르는 것이 대세이다.
<br>
<br>
접두어 코드는 코드 집합의 어느 코드도 다른 코드의 접두어가 되지 않는 코드를 말한다.(이것을 접두어 속성(Prifix Property)라고 함)
<br>
예를 들어 코드 집합 { "0", "1", "01", "010" }은 접두아 코드가 아니다.
<br>
"0"이 "01"과 "010"의 접두어가 되기 때문이다.
<br>
<br>
반면 {"00", "010", "100", "101" }은 어느 코드도 다른 코드어의 접두어가 되지 않기 때문에 접두어 코드라고 할 수 있다.
<br>
<br>
예를 들어 a, b, c, d를 나타내는 접두어 코드가 다음과 같이 정의되어 있다고 가정한다.

```
a = 00
b = 010
c = 100
d = 101
```

이 코드대로라면 'abcd'는 00010100101 로 표현할 수 있다.
<br>
ASCII 로는 32bit가 필요한데, 접두어 코드로는 11bit 만으로 표현할 수 있다.
<br>
<br>
허프만 코딩은 이런 아이디어에 근거를 두고 있다.

<br>

## 허프만 트리 구축
허프만 코딩 알고리즘을 이해하려면 딱 두 가지만 기억하면 된다.
- 기호와 빈도
- 이진 트리

기호의 빈도는 한 기호가 데이터 안에서 차지하는 비율을 말한다.
<br>
'Programming' 이라는 문자열을 예로 들어보면 길이는 11이고 기호 'g', 'm', 'r'의 빈도는 2이며 'P', 'o', 'i'의 빈도는 1이다.
<br>
<br>
기호의 빈도는 길이가 짧은 접두어 코드를 빈도가 가장 높은 기호에 부여하기 위해 사용한다.
<br>
빈도가 높은 기호에 작은 접두어 코드를 부여하면 그만큼 저장 공간을 아낄 수 있기 때문이다.
<br>
즉, 압축률이 높아진다는 뜻이다.
<br>
<br>
예를 들어 어떤 문자열이 'a' 기호 20개와 'b' 기호 5개로 이루어진다고 가정한다.
<br>
'a'에 코드 100을, 'b'에 코드 11을 부여한다면 변환된 데이터의 크기는 3(100의 비트 수) * 20 + 2(11의 비트수) * 5 = 70 비트가 된다.
<br>
<br>
원본 문자열이 200비트 였으니 원본 크기 대비 35%로 압축되었다.
<br>
하지만 반대로 a에 코드 11, b에 코드 100을 부여한다면 2(11의 비트 수) * 20 + 3(100의 비트 수) * 5 = 55로 앞의 방법에 비해 15비트를 더 절약할 수 있다.
<br>
<br>
이진 트리는 접두어 코드를 표현하기 위해 사용한다.
<br>
트리의 노드에서 왼쪽 자식 노드는 0, 오른쪽 자식 노드는 1을 가리킨다.
<br>
<br>
이 트리에서 모든 기호는 잎 노드에만 기록되어 있으며 뿌리 노드에서부터 잎 노드까지 이르는 경로가 기호의 접두어 코드가 된다.
<br>
이러한 방식으로 접두어 코드를 표현하는 이진 트리를 허프만 트리(Huffman Tree) 라고 한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/aebdfc83-b6f2-4929-8917-cc23812e6e64)


<br>

이 트리를 보면 잎 노드는 모두 4개이고 노드들에 저장된 기호는 a, b, c, d이다.
<br>
뿌리 노드로부터 a 노드까지 이르는 경로는 0 하나 뿐이다.
<br>
따라서 a의 접두어 코드는 0이 된다.
<br>
<br>
뿌리 노드로부터 b 노드까지 이르는 경로에는 오른쪽(1), 왼쪽(0), 왼쪽(0) 노드가 존재하므로 100이 된다.
<br>
같은 방법으로 c와 d를 읽어보면 c는 101, d는 11이 된다.
<br>
<br>
여기서 알 수 있는 사실이 탐욕 알고리즘과 허프만 트리의 상관관계이다.
<br>
이 트리의 뿌리 노드에서 잎 노드에 이르는 경로가 길어지면 길어질수록 접두어 코드 역시 길어진다는 사실이다.
<br>
여기서 기호의 빈도는 기호를 어느 잎 노드에 입력할 것인가를 결정하기 위해 사용한다.
<br>
<br>
빈도가 높은 기호일수록 경로를 짧게, 빈도가 낮은 기호일수록 경로를 길게 가져가야 압축률이 높아진다.
<br>
그래서 빈도수가 높은 기호부터 경로가 짧은 노드를 차지할 수 있도록 만들어야 한다.
<br>
<br>
예를 들어 'aaabaacdd' 라는 문자열이 있다.
<br>
a의 빈도는 5이고 b, c는 1, 그리고 d는 2이다.
<br>
<br>
먼저 이 기호들은 빈도와 함께 다음 그림과 같이 노드로 생성한다.
<br>
여기서 원 위의 숫자는 빈도를 나타낸다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/833a843f-f3e6-4649-a275-4012c64a5d82)


<br>

허프만 트리에서 기호는 잎 노드에만 저장되므로 이 노드들은 끝까지 잎 노드로 남아야 한다.
<br>
따라서 이 노드들 위에 부모 노드를 만들어 연결시키면서 트리를 완성해야 한다.
<br>
<br>
지금부터는 탐욕 알고리즘의 3단계를 적용해서 이 문제를 풀어나가면 된다.
1. 해 선택
2. 실행 가능성 검사
3. 해 검사

우선 해를 선택해야 한다.
<br>
선택 기준은 현 시점에서 빈도가 가장 작은 노드 2개이다.
<br>
<br>
b, c가 모두 빈도 1로 가장 작은 노드들이므로 이 노드를 선택한 후 노드 위에 부모 노드를 새로 만들어 각각 왼쪽과 오른쪽에 연결시킨다.
<br>
<br>
이때 부모 노드의 빈도는 자식 노드 빈도의 합이 된다.
<br>
따라서 b, c의 부모 노드의 빈도는 2가 된다.
<br>
<br>
마지막으로 새로 만든 부모 노드를 노드 집합에 추가한다.
<br>
<br>
이제 실행 가능성 검사를 해야 한다.
<br>
기호를 가진 노드는 잎 노드여야 하는데 아직까지는 이 규칙을 위반하지 않고 있다.
<br>
따라서 실행 가능성 검사를 통과한다.
<br>
<br>
다음으로 해 검사를 해야 하는데, 허프만 트리를 완성하지 못했으므로 해 검사는 통과하지 못한다.
<br>
그래서 다시 해 선택 단계로 돌아가야 한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/96d4c93b-75b5-48dd-9e1a-ee275d0a7b27)


<br>

현재 상태에서는 이전 단계에서 새로 만든 노드(b, c의 부모 노드)와 d 노드의 빈도가 가장 작으므로 이 두 노드를 선택한다.
<br>
부모 노드를 새로 만들어 여기에 b, c의 부모 노드와 d 노드를 자식 노드로 연결시킨다.
<br>
<br>
기호를 가진 노드들은 잎 노드이므로 이번에도 실행 가능성 검사를 통과한다.
<br>
트리에 들어가지 못한 노드가 남아 있기 때문에 다시 해 선택 단계로 돌아간다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/26f15fbc-3a11-48f4-b977-14331268c0d4)


<br>

다시 해 선택 단계로, 빈도가 가장 작은 2개의 노드를 골라야 하는데 남은 노드는 2개이다.
<br>
새 노드를 만들고 여기에 노드 a와 b, c, d의 뿌리 노드를 자식 노드로 연결시킨다.
<br>
이제 이 새로운 노드를 노드 집합에 추가한다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/ac3a8960-648c-4188-89fd-2129d155c12b)


<br>

이제 노드 집합에는 단 하나의 노드만 남아 있다.
<br>
이것은 곧 접두어 트리가 완성되었음을 의미한다.
<br>
<br>
이제 이 집합에서 남아 있는 노드를 꺼내면 이 노드가 곧 허프만 트리가 된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/b355333e-f927-4ee4-a356-26e0cc56df52)


<br>

여기까지가 탐욕 알고리즘의 예제로 완성된 허프만 코딩 알고리즘이다.

## 데이터 압축
허프만 트리는 압축을 위해 만들었으므로, 이를 이용하여 'aaabaacdd'를 압축하려고 한다.
<br>
문자열의 각 요소를 차례대로 읽으면서 허프만 트리가 나타내는 해당 문자의 접두어 코드로 변환하면 압축이 된다.
<br>
<br>
압축 결과는 다음과 같다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/c905f03d-dbe2-4191-8a3d-72b83e7b12eb)

<br>

압축 결과는 000100001011111 이고 원본 데이터(ASCII)의 크기가 72비트 였는데 15비트로 압축되었다.

<br>


## 데이터 압축 해제
허프만 코딩은 압축뿐 아니라 압축을 풀어내는 방법도 제공한다.
1. 허프만 트리와 압축 해제된 데이터가 담길 버퍼를 준비
2. 압축 데이터에 아직 읽지 않은 부분이 남아 있다면 데이터를 한 비트 읽음
3. 읽어낸 비트가 0이면 현재 노드의 왼쪽 자식 노드, 1이면 오른쪽 자식 노드로 이동하며 현재 노드가 잎 노드면 버퍼에 저장된 기호를 추가하고 다시 뿌리 노드로 이동

쉽게 말해 비트를 읽을 때마다 잎 노드를 만나기 전까지 허프만 트리의 왼쪽과 오른쪽 노드를 순회하라는 의미이다.
<br>
이제 예를 들기 위해 000100001011111을 복원한다고 가정한다.
<br>
<br>
먼저 다음 그림과 같이 허프만 트리, 압축 해제된 데이터를 담는 용도로 사용할 버퍼, 압축 데이터를 준비한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/2db23f5a-f4cc-4c7d-bd41-b88c6edc236b)


<br>

그리고 압축 데이터에서 비트 하나를 읽는데, 0이므로 왼쪽 노드로 이동해야 한다.
<br>
이동하니 잎 노드 a가 나왔으므로 a를 압축 해제 버퍼에 추가하고 뿌리 노드로 돌아간다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/c0acc483-2e85-43fb-a698-cad035f50eef)


<br>

세 번째 비트까지는 0이 읽히기 때문에 매번 a 노드를 만나게 된다.
<br>
그러면 그때마다 a를 압축 해제 버퍼에 추가하고 뿌리 노드로 돌아가면 된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/bd0251fd-1ece-446a-913b-f3c79e17796a)


<br>

그 다음 비트를 읽었더니 1이 나왔으므로 뿌리 노드에서 오른쪽 노드로 이동했는데 잎 노드가 아니다.
<br>
이 경우에는 그 다음 비트를 읽어야 하며, 읽었더니 0이 나왔다.
<br>
<br>
현재 위치에서 왼쪽 자식 노드를 이동하고, 이번에도 잎 노드가 아니므로 또 비트 하나를 읽는다.
<br>
0이 나와서 왼쪽 자식 노드로 이동했더니 b가 나타났다.
<br>
b를 압축 해제 버퍼에 추가하고 뿌리 노드로 돌아가서 다시 처음부터 순회할 준비를 한다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/41a0ce8c-e392-4e7d-839c-7d2e168d130b)

<br>

그 이훌 ㅗ압축 데이터에서 0만 두 번 연속 나왔으므로 2개의 a가 압축 해제 버퍼에 추가된다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/dc128f96-f3ee-40ec-8447-11b5180ff786)


<br>

이번에 읽은 비트는 1이므로 뿌리 노드의 오른쪽 자식 노드로 이동하고 다시 비트를 읽는다.
<br>
읽은 비트가 0이므로 현재 노드이ㅡ 왼쪽 자식 노드로 이동하고 또 비트를 읽는다.
<br>
<br>
이번에는 1이 나왔으므로 오른쪽 자식 노드로 이동한다.
<br>
이번에 도달한 노드는 잎 노드 c이므로 c를 압축 해제 버퍼에 추가하고 다시 뿌리 노드로 돌아간다.

<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/0afbf438-8ded-43f1-9017-705625c578a6)

<br>

또 비트 하나를 읽었는데 1이 나왔다.
<br>
뿌리 노드의 오른쪽 자식 노드로 이동하고, 이동한 노드가 잎 노드가 아니므로 다시 비트 하나를 더 읽는다.
<br>
<br>
이번에도 1이 나왔으므로 오른쪽 자식 노드로 이동한다.
<br>
이번에는 잎 노드를 만났는데 기호 d가 저장되어 있으므로 d를 압축 해제 버퍼에 추가하고 다시 뿌리 노드로 돌아간다.
<br>

![image](https://github.com/JeHeeYu/Book-Reviews/assets/87363461/42e86205-5f93-47d3-bb6f-4dbc48aa5461)

<br>
압축 데이터에 남은 버퍼가 11뿐이므로 방금 했던 일을 반복하면 된다.
<br>
또 하나의 d를 압축 해제 버퍼에 추가하고 나면 압축 해제가 종료된다.
<br>
<br>
000100001011111을 압축 해제해서 'aaabaacdd'를 얻었으므로 원본과 동일하다.

<br>

### [예제 코드](https://github.com/JeHeeYu/Algorithm/blob/main/Greedy/Huffman/Huffman.c)

### 실행 결과

```
Original Size : 160 Encoded Size : 71
Original : This Is Algorithms.
Encoded : 10111000101100000111110000111111010001011110111000100011100111011100110
Decoded : This Is Algorithms.
```
