# 탐욕 알고리즘 정리 내용

## 탐욕(Greedy) 알고리즘
탐욕 알고리즘은 최적화 문제의 답을 얻기 위해 사용된다.
<br>
탐욕 이라는 이름은 각 단계의 부분 문제를 풀 때 근시안 적으로 최적해를 구한다고 해서 붙여졌다.
<br>
그래서 탐욕 알고리즘을 생각할 때는 욕심이나 탐욕 자체보다 탐욕이 우리로 하여금 가까운 것만 바라보게 하는 효과에 초점을 맞추는 편이 이해하는 데 도움이 된다.
<br>
<br>
탐욕 알고리즘은 반드시 최적해를 구해준다는 보장은 하지 못한다.
<br>
다만 최적해가 나오기를 '바랄' 수 있을 뿐이다.
<br>
<br>
탐욕 알고리즘으로 풀 수 있는 문제는 다음과 같이 대상 문제가 최적 부분 구조를 갖고 있어야 한다.
<br>
탐욕 알고리즘은 다음과 같은 과정으로 동작한다.
1. <b>해 선택</b> : 현재 상태에서 부분 문제의 최적해를 구한 후 이를 부분해 집합(Solution Set)에 추가
2. <b>실행 가능성 검사</b> : 새로운 부분해 집합이 실행 가능한 것인지 확인 즉, 문제의 제약 조건을 위반하지 않는지 검사
3. <b>해 검사</b> : 새로운 부분해 집합이 문제의 해가 되는지 확인하며 아직 전체 문제의 해가 완성되지 않았다면 1단계의 해 선택부터 다시 시작

<br>

## 거스름돈 줄이기 문제
거스름돈 줄이기 문제는 탐욕 알고리즘에서 많이 사용되는 문제이다.
<br>
예를 들어 편의점에서 손님에게 거스름돈을 주는 것을 최소한으로 줄일 수 있는 부분을 생각하는 상황이라고 가정한다.
<br>
<br>
예를 들어 물건 가격이 1,200 원인데, 손님이 1,000원짜리 지폐 2개를 지불하면 거스름돈 800원을 내어 주어야 한다.
<br>
이때 거스름돈을 100원짜리 8개로 줄 수도 있지만, 동전의 개수를 최소한으로 하려면 500원짜리 1개와 100원짜리 3개를 내어주어야 한다.
<br>
<br>
이 문제는 탐욕 알고리즘을 잘 이해할 수 있는 좋은 사례이다.
<br>
이 문제를 1단계 해 선택, 2단계 실행 가능성 검사, 3단계 해 검사로 정의하면 다음과 같다.
1. <b>해 선택</b> : 현재 고를 수 있는 가장 큰 단위의 동전을 하나 골라 거스름돈에 추가
2. <b>실행 가능성 검사</b> : 거스름돈이 손님에게 내주어야 할 액수보다 초과하는지 확인하고 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1단계로 돌아가서 현재보다 한 단계 작은 단위의 동전 추가
3. <b>해 검사</b> : 거스름돈 문제의 해를 구하는 단계로 거스름돈 액수가 모자라면 1단계로 돌아가 추가할 동전 선택

<br>

## 거스름돈 계산 예제 프로그램

### [예제 코드](https://github.com/JeHeeYu/Algorithm/blob/main/Greedy/Change.c)

### 실행 결과

```
동전의 가짓수를 입력하세요 : 4
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 100
[2] 번째 동전의 단위를 입력하세요 : 50
[3] 번째 동전의 단위를 입력하세요 : 10
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
     500원 : 1개
     100원 : 3개
      50원 : 0개
      10원 : 0개
```

<br>

## 탐욕 알고리즘의 중요한 속성
대부분의 국가에서 사용하는 지폐와 동전의 단위는 탐욕 알고리즘이 항상 최적의 거스름돈을 만들 수 있는 형식으로 되어 있다.
<br>
예를 들어 우리나라의 동전은 500원, 100원, 50원, 10원 이렇게 네 가지가 있다.
<br>
이 다섯 가지 중 어느 두 개를 골라 두 동전 사이의 최대 공약수를 계사냏도 항상 작은 값의 동전 단위가 나온다.
<br>
<br>
예를 들어 500과 100의 최대 공약수는 100이고, 100과 10의 최대 공약수도 10이다.
<br>
<br>
이와 같은 체계에서는 누구나 최소 개수의 동전으로 이루어진 거스름돈을 만들 수 있다.
<br>
<br>
만약 400원짜리 동전을 새로 발행되었다고 가정한다.
<br>
400원짜리 동전이 있는 경우 800원의 거스름돈을 만들기 위한 최적의 해는 400원짜리 동전 2개를 내주는 것이다.
<br>
하지만 작성한 알고리즘대로라면 500원짜리를 먼저 선택해서 1개를 거스름돈에 추가하고 그 다음에서 400원짜리 동전을 선택하면 실행 가능성 검사에서 부적격 판정을 받는다.
<br>
500 + 400 = 900이 되므로 손님에게 내주어야 할 돈 800원을 초과하기 때문이다.
<br>
<br>
결국 다음 단계에서 100원짜리를 선택하게 되고 모두 4개의 동전을 손님에게 내주는 결과를 얻게 된다.

```
동전의 가짓수를 입력하세요 : 5
[0] 번째 동전의 단위를 입력하세요 : 500
[1] 번째 동전의 단위를 입력하세요 : 400
[2] 번째 동전의 단위를 입력하세요 : 100
[3] 번째 동전의 단위를 입력하세요 : 50
[4] 번째 동전의 단위를 입력하세요 : 10
물건 가격을 입력하세요 : 1200
손님이 지불한 돈은 얼마입니까? : 2000
     500원 : 1개
     400원 : 0개
     100원 : 3개
      50원 : 0개
      10원 : 0개
```

이 실행 결과를 살펴보면 거스름돈을 만드는 **탐욕 알고리즘의 해가 항상 최적은 아니다** 라는 사실을 알 수 있다.
<br>
거스름돈 알고리즘 처럼 항상 **최적의 결과를 보장하지 못한다는 부분**은 탐욕 알고리즘의 중요한 속성이다.
