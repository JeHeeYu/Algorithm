## 이진 트리(Binary Tree)란
이진 트리란 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리 구조를 말한다.  
이때 각 노드의 자식은 2명 이하만 유지해야 한다.  
  
![image](https://user-images.githubusercontent.com/87363461/205423076-d7c1c1c9-efc5-4593-b274-fdf9181d9d27.png)  

이진 트리의 특징은 왼쪽 자식과 오른쪽 자식을 구분한다는 점이 있다.  
위 그림에서 노드 B의 왼쪽 자식은 D, 오른쪽 자식은 E이다.  
  
이때 왼쪽 자식을 다시 루트로 하는 서브 트리를 왼쪽 서브 트리(Left Subtree),  
반대로 오른쪽 자식을 다시 루트로 하는 트리를 오른쪽 서브 트리(Right Subree)라고 한다.  
  
  <br>
    
## 완전 이진 트리(Complete Binary Tree)
완전 이진 트리란 루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽 노드가 채워져있는 이진 트리 구조를 말한다.  
여기서 채운다는 개념이 인덱스가 채워져 있는 개념으로 볼 수 있다.  

완전 이진 트리에서 마지막 레벨을 제외한 레벨은 노드를 가득 채운다.  
그리고 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없다.  
  
![image](https://user-images.githubusercontent.com/87363461/205423667-a0ee5e00-aa91-4848-8c6e-56e387bb009f.png)  
  
위 그림과 같이 완전 이진 트리에서 너비 우선 탐색을 하며 각 노드에 0부터 차례로 값을 준다.  
배열에 저장하는 인덱스와 일대일로 대응되는 것을 볼 수 있다.  
  
높이가k인 완전 이진 트리가 가질 수 있는 노드의 최댓값은 2 ^ (k + 1) - 1개 이다.  
따라서 n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 log n 이다.

<br>
  
## 이진 탐색 트리(Binary Search Tree)
이진 탐색 트리란 트리 내부에 있는 노드의 값을 찾는 방법으로 아래와 같이 3가지의 조건을 만족하면 된다.
<ol>
  <li>각 노드는 왼쪽 자식 노드보다 큼</li>
  <li>각 노드는 오른쪽 자식보다 작음</li>
  <li>같은 키 값을 갖는 노드는 없음</li>
</ol>

![image](https://user-images.githubusercontent.com/87363461/205424063-119ee3cd-fb12-41f4-84ed-ac17664d0b85.png)  


위 그림은 이진 탐색 트리를 구현한 예이다.  
여기서 노드 5를 보면 왼쪽 서브 트리 노드(4, 1)은 모두 5보다 작다. (조건 1번에 해당)  
그리고 오른쪽 서브 트리 노드(7, 6, 9)는 모두 5보다 크다. (조건 2번에 해당)
  
이때 이진 탐색 트리를 중위 순회(Inorder)하면 다음과 같이 키 값의 오름차순으로 노드를 얻을 수 있다.  
```
1 -> 4 -> 5 -> 6 -> 7 -> 9 -> 11 -> 12 -> 13 -> 14 -> 15 -> 18
```

이와 같이 이진 탐색 트리는 중위 순회를 하면 몇 가지의 장점이 있어 자주 사용된다.
<ul>
  <li>키 값의 오름차순으로 노드를 얻을 수 있음</li>
  <li>구조가 단순하여 구현이 쉬움</li>
  <li>이진 탐색과 비슷한 방식으로 탐색 가능</li>
  <li>노드의 삽입이 용이함</li>
</ul>

## 이진 트리에서의 이진 탐색
이진 트리 탐색에서 가장 중요한 전제 조건은 이진 탐색이 가능한 상태로 정렬되어 있어야 한다.  
(이진 탐색도 배열이 정렬되어 있어야 탐색이 가능한 것 처럼)  
  
이진 트리에서 탐색을 하기 위해 이진 탐색 트리의 가장 중요한 아래 조건을 알고 있어야 한다.  

<ol>
  <li>각 노드는 왼쪽 자식 노드보다 큼</li>
  <li>각 노드는 오른쪽 자식보다 작음</li>
  <li>같은 키 값을 갖는 노드는 없음</li>
</ol>

여기서 중요한 점은 각 노드는 왼쪽 자식보다 크고 오른쪽 자식보다 작은데, 이 각 노드를 <b>중앙 요소</b>라고 한다.  
예를 들어 아래와 같은 트리가 있다.  

![image](https://user-images.githubusercontent.com/87363461/205424833-756ae022-abcd-427a-9bc5-f66f66688713.png)
  
위 트리에서 루트 노드는 23이고, 23은 트리 전체의 <b>중앙 요소</b>이다.  
23 노드의 왼쪽에는 23보다 작은 값들만 있고, 오른쪽에는 23보다 큰 값들만 존재한다.
  
    
하위 트리로 내려가도 같은 규칙이 적용되고 있다.  
23 노드 왼쪽 하위 트리의 노드는 11인데, 11 노드의 왼쪽에는 작은 값(1), 오른쪽에는 큰 값(14)가 있다.  
  
마찬가지로23 노드 오른쪽 하위 트리의 노드도 같은 규칙이 적용되어 있다.
  
  
이처럼 중앙 요소를 찾아 좌우의 대소를 비교하여 탐색 범위를 정하고, 또 다시 중앙 요소를 찾아 좌우의 대소를 비교하는 일을 반복한다.  
이렇게 보면 배열에서 이진 탐색을 하는 것과 동일하다.  
  <br>
  
## 이진 트리 탐색 과정

아래 예제가 트리에서 67을 찾는 과정이다.  

먼저 루트 노드인 23 노드와 목표값 67을 비교한다.  
비교 시 목표 값이 더 큰 것을 알 수 있으며, 이 경우 왼쪽을 버리고 오른쪽으로 탐색 대상을 좁히고 다시 탐색한다.  

![image](https://user-images.githubusercontent.com/87363461/205424941-fe6e1886-c2fd-4a09-82af-a340fa4abceb.png)  


139는 67보다 크므로 중앙 요소인 139 노드를 기준으로 오른쪽을 버리고 다시 왼쪽으로 탐색 대상을 좁힌다.  

![image](https://user-images.githubusercontent.com/87363461/205425027-80cd8917-a266-4c26-b245-3dbdd0979dfe.png)  

왼쪽 노드를 확인해 보니 찾고자 하는 67과 같은 값인 것을 확인할 수 있다.  

![image](https://user-images.githubusercontent.com/87363461/205425053-93ec72a5-d927-47de-b0e7-df4e7010f7d9.png)  

<br>

## 이진 트리 삽입 과정
이진 트리 삽입 과정 중 노드 삽입 연산의 핵심은 <b>새 노드가 삽입될 곳이 어디인지</b>를 찾아내는 부분이다.  
즉, 새 노드가 삽입될 곳을 이진 탐색으로 찾아내야 한다.  
  
이진 탐색으로 새 노드를 연결할 부모 노드를 찾아낸 후 그곳에 노드를 놓으면 노드 삽입 연산이 완료된다.  

예를 들어 아래 예제로 트리에서 14를 삽입하는 과정을 나타낸다.  

![image](https://user-images.githubusercontent.com/87363461/205425193-da7ae1ad-04aa-47e1-b4fc-edc5bc0a6541.png)  

14는 23보다 작으므로 23의 왼쪽 하위 트리에 위치해야 하고, 11보다 크므로 11의 오른쪽 하위 트리에 위치해야 한다.  

![image](https://user-images.githubusercontent.com/87363461/205425212-ba1fc2fa-4b04-4452-b009-cfed27643e36.png)

<br>

## 노드 삭제 연산

