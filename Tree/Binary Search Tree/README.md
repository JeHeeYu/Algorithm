## 요약

### 시간 복잡도 : O(log(n)) ~ O(n)

<ul>
  <li>왼쪽 하위 트리는 루트보다 작은 값이 위치함</li>
  <li>오른쪽 하위 트리는 루트보다 큰 값이 위치함</li>
  <li>정렬되어 있는 트리 구조에서 빠른 탐색 속도를 보임</li>
  <li>한쪽으로 편향되어 있는 트리 구조에서 비효율적임</li>
</ul>

## 이진 트리(Binary Tree)란
이진 트리란 노드가 왼쪽 자식과 오른쪽 자식을 갖는 트리 구조를 말한다.  
이때 각 노드의 자식은 2명 이하만 유지해야 한다.  
  
![image](https://user-images.githubusercontent.com/87363461/205423076-d7c1c1c9-efc5-4593-b274-fdf9181d9d27.png)  

이진 트리의 특징은 왼쪽 자식과 오른쪽 자식을 구분한다는 점이 있다.  
위 그림에서 노드 B의 왼쪽 자식은 D, 오른쪽 자식은 E이다.  
  
이때 왼쪽 자식을 다시 루트로 하는 하위 트리를 왼쪽 하위 트리,    
반대로 오른쪽 자식을 다시 루트로 하는 트리를 오른쪽 하위 트리라고 한다.  
  
  <br>
    
## 완전 이진 트리(Complete Binary Tree)
완전 이진 트리란 루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽 노드가 채워져있는 이진 트리 구조를 말한다.  
여기서 채운다는 개념이 인덱스가 채워져 있는 개념으로 볼 수 있다.  

완전 이진 트리에서 마지막 레벨을 제외한 레벨은 노드를 가득 채운다.  
그리고 마지막 레벨은 왼쪽부터 오른쪽 방향으로 노드를 채우되 반드시 끝까지 채울 필요는 없다.  
  
![image](https://user-images.githubusercontent.com/87363461/205423667-a0ee5e00-aa91-4848-8c6e-56e387bb009f.png)  
  
위 그림과 같이 완전 이진 트리에서 너비 우선 탐색을 하며 각 노드에 0부터 차례로 값을 준다.  
배열에 저장하는 인덱스와 일대일로 대응되는 것을 볼 수 있다.  
  
높이가k인 완전 이진 트리가 가질 수 있는 노드의 최댓값은 2 ^ (k + 1) - 1개 이다.  
따라서 n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 log n 이다.

<br>
  
## 이진 탐색 트리(Binary Search Tree)
이진 탐색 트리란 트리 내부에 있는 노드의 값을 찾는 방법으로 아래와 같이 3가지의 조건을 만족하면 된다.
<ol>
  <li>각 노드는 왼쪽 자식 노드보다 큼</li>
  <li>각 노드는 오른쪽 자식보다 작음</li>
  <li>같은 키 값을 갖는 노드는 없음</li>
</ol>

![image](https://user-images.githubusercontent.com/87363461/205424063-119ee3cd-fb12-41f4-84ed-ac17664d0b85.png)  


위 그림은 이진 탐색 트리를 구현한 예이다.  
여기서 노드 5를 보면 왼쪽 하위 트리 노드(4, 1)은 모두 5보다 작다. (조건 1번에 해당)  
그리고 오른쪽 하위 트리 노드(7, 6, 9)는 모두 5보다 크다. (조건 2번에 해당)
  
이때 이진 탐색 트리를 중위 순회(Inorder)하면 다음과 같이 키 값의 오름차순으로 노드를 얻을 수 있다.  
```
1 -> 4 -> 5 -> 6 -> 7 -> 9 -> 11 -> 12 -> 13 -> 14 -> 15 -> 18
```

이와 같이 이진 탐색 트리는 중위 순회를 하면 몇 가지의 장점이 있어 자주 사용된다.
<ul>
  <li>키 값의 오름차순으로 노드를 얻을 수 있음</li>
  <li>구조가 단순하여 구현이 쉬움</li>
  <li>이진 탐색과 비슷한 방식으로 탐색 가능</li>
  <li>노드의 삽입이 용이함</li>
</ul>

## 이진 트리에서의 이진 탐색
이진 트리 탐색에서 가장 중요한 전제 조건은 이진 탐색이 가능한 상태로 정렬되어 있어야 한다.  
(이진 탐색도 배열이 정렬되어 있어야 탐색이 가능한 것 처럼)  
  
이진 트리에서 탐색을 하기 위해 이진 탐색 트리의 가장 중요한 아래 조건을 알고 있어야 한다.  

<ol>
  <li>각 노드는 왼쪽 자식 노드보다 큼</li>
  <li>각 노드는 오른쪽 자식보다 작음</li>
  <li>같은 키 값을 갖는 노드는 없음</li>
</ol>

여기서 중요한 점은 각 노드는 왼쪽 자식보다 크고 오른쪽 자식보다 작은데, 이 각 노드를 <b>중앙 요소</b>라고 한다.  
예를 들어 아래와 같은 트리가 있다.  

![image](https://user-images.githubusercontent.com/87363461/205424833-756ae022-abcd-427a-9bc5-f66f66688713.png)
  
위 트리에서 루트 노드는 23이고, 23은 트리 전체의 <b>중앙 요소</b>이다.  
23 노드의 왼쪽에는 23보다 작은 값들만 있고, 오른쪽에는 23보다 큰 값들만 존재한다.
  
    
하위 트리로 내려가도 같은 규칙이 적용되고 있다.  
23 노드 왼쪽 하위 트리의 노드는 11인데, 11 노드의 왼쪽에는 작은 값(1), 오른쪽에는 큰 값(14)가 있다.  
  
마찬가지로23 노드 오른쪽 하위 트리의 노드도 같은 규칙이 적용되어 있다.
  
  
이처럼 중앙 요소를 찾아 좌우의 대소를 비교하여 탐색 범위를 정하고, 또 다시 중앙 요소를 찾아 좌우의 대소를 비교하는 일을 반복한다.  
이렇게 보면 배열에서 이진 탐색을 하는 것과 동일하다.  
  <br>
  
## 이진 트리 노드 탐색 과정

아래 예제가 트리에서 67을 찾는 과정이다.  

먼저 루트 노드인 23 노드와 목표값 67을 비교한다.  
비교 시 목표 값이 더 큰 것을 알 수 있으며, 이 경우 왼쪽을 버리고 오른쪽으로 탐색 대상을 좁히고 다시 탐색한다.  

![image](https://user-images.githubusercontent.com/87363461/205424941-fe6e1886-c2fd-4a09-82af-a340fa4abceb.png)  


139는 67보다 크므로 중앙 요소인 139 노드를 기준으로 오른쪽을 버리고 다시 왼쪽으로 탐색 대상을 좁힌다.  

![image](https://user-images.githubusercontent.com/87363461/205425027-80cd8917-a266-4c26-b245-3dbdd0979dfe.png)  

왼쪽 노드를 확인해 보니 찾고자 하는 67과 같은 값인 것을 확인할 수 있다.  

![image](https://user-images.githubusercontent.com/87363461/205425053-93ec72a5-d927-47de-b0e7-df4e7010f7d9.png)  

<br>

## 이진 트리 노드 삽입 과정
이진 트리 삽입 과정 중 노드 삽입 연산의 핵심은 <b>새 노드가 삽입될 곳이 어디인지</b>를 찾아내는 부분이다.  
즉, 새 노드가 삽입될 곳을 이진 탐색으로 찾아내야 한다.  
  
이진 탐색으로 새 노드를 연결할 부모 노드를 찾아낸 후 그곳에 노드를 놓으면 노드 삽입 연산이 완료된다.  

예를 들어 아래 예제로 트리에서 14를 삽입하는 과정을 나타낸다.  

![image](https://user-images.githubusercontent.com/87363461/205425193-da7ae1ad-04aa-47e1-b4fc-edc5bc0a6541.png)  

14는 23보다 작으므로 23의 왼쪽 하위 트리에 위치해야 하고, 11보다 크므로 11의 오른쪽 하위 트리에 위치해야 한다.  

![image](https://user-images.githubusercontent.com/87363461/205425212-ba1fc2fa-4b04-4452-b009-cfed27643e36.png)

<br>

## 이진 트리 노드 삭제 과정
이진 트리에서 노드를 삭제하기 위해 먼저 삭제할 노드를 찾아야 한다.  
이 작업은 이진 탐색을 통해 찾으며, 탐색 이후 노드가 어디에 있는지 알아내고, 그 노드를 삭제한다.  
  
이때 삭제하는 노드가 잎 노드(Leaf Node)라면 문제 없이 부모 노드에서 자식 노드의 포인터를 NULL로 주고, 삭제한 노드의 주소를 반환하면 작업이 마무리 된다.  
  
아래 예제는 이진 트리에서 14 노드를 제거하는 과정을 나타낸다.  
14 노드는 자식이 없으므로 그냥 트리에서 해당 노드를 삭제하고, 11의 오른쪽 자식 노드를 NULL로 초기화하면 된다.  

![image](https://user-images.githubusercontent.com/87363461/205425654-91226ddd-ee35-432d-a927-09ca822f05fd.png)  

위 처럼 자식이 없을 경우는 간단하지만, 자식이 있는 경우는 조금 더 복잡해진다.  
자식 노드가 있을 경우에도 두 가지로 나뉜다.

<ul>
  <li>양쪽 자식 노드를 모두 갖고 있는 경우</li>
  <li>왼쪽과 오른쪽 중 어느 한쪽 자식 노드만 갖고 있는 경우</li>
</ul>

먼저 두 번째 경우인 한쪽 자식만 가진 노드를 처리하는 부분은 양쪽 자식이 있을 경우보다 상대적으로 간단하다.  
삭제할 노드의 자식을 삭제할 노드의 부모에 연결만 시키면 된다.  
  
    
아래 그림은 한쪽 자식의 노드를 삭제하는 과정으로, 139 노드를 삭제한다.  
그 후 해당 노드를 가리키던 부모 노드(23)의 오른쪽 자식 포인터를 67 노드에 연결한다.  

![image](https://user-images.githubusercontent.com/87363461/205425763-72fec60b-14e0-493b-befe-8679c1fdf6aa.png)  

위와 같이 한쪽 자식이 있을 경우는 간단하게 마무리 되었지만, 양쪽 자식이 있는 경우는 다르다.  
아래 그림은 양쪽 자식이 있는 경우이며, 11을 삭제하는 경우이다.  

![image](https://user-images.githubusercontent.com/87363461/205426043-bd67e554-ddf1-469d-8b72-88ba342fa309.png)  


먼저 삭제된 노드의 오른쪽 하위 트리에서 가장 작은 값을 가진 노드(최솟값 노드)를 삭제된 노드의 위치에 옮겨놓는다.  
삭제된 11노드의 오른쪽 하위 트리에서 가장 작은 13 노드를 옮겨 11 노드가 있던 자리에 놓는다.  

![image](https://user-images.githubusercontent.com/87363461/205425928-6fd30855-8385-4658-8292-eccce7e6d3ed.png)  

옮겨 놓은 최솟값 노드가 자식이 없는 경우라면 이렇게 노드를 빈자리에 옮겨 놓는 것만으로 작업이 완료된다.  
하지만 자식이 있는 경우 추가 작업을 해주어야 한다.  
  
추가 작업이 필요한 이유는 왼쪽 자식이 있으면 자기보다 작은 값을 가진 노드가 하위 트리에 있다는 뜻인데,  
이렇게 되면 최솟값 노드가 더 이상 최솟값 노드가 아니게 되기 때문이다.  
  
마지막으로 최솟값 노드의 오른쪽 자식을 최솟값 노드의 원래 부모에게 연결하면 삭제 작업이 모두 완료된다.  
이 경우는 15 노드를 16 노드의 왼쪽 자식으로 만들면 된다.  

![image](https://user-images.githubusercontent.com/87363461/205426023-f011e289-71ca-4680-bcde-3b48883da328.png)  

<br>

## 이진 탐색 트리의 문제점
이진 탐색 트리는 정렬되어 있는 데이터 구조에서는 탐색 속도도 빠르고 잘 처리할 수 있지만, 기형적인 데이터 구조에서는 효율이 많이 떨어진다.  

![image](https://user-images.githubusercontent.com/87363461/205429636-9455c164-a8ff-4249-914a-881c5d9e062d.png)  

이 경우 Red-Black 트리 또는 AVL 트리로 해결해야 한다.
