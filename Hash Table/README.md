## 해시 테이블(Hash Table)

## 해시(Hash)
해시란 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(Mapping)한 값이다.
<br>
즉, 해시는 데이터를 입력받아 완전히 다른 모습의 데이터로 바꾸는 작업을 말한다.
<br>
<br>
해시를 이용하여 탐색 알고리즘인 해시 테이블 알고리즘, SHA, MD5 암호화 알고리즘, 데이터 축약 등과 같은 용도로 사용한다.
<br>


## 해시 테이블(Hash Table)
해시 테이블이란 쉽게 말해 데이터의 해시(Hash)값을 얻어 테이블 내의 주소로 사용하는 것이다.
<br>
예를 들어 배열을 선언하면 메모리에 일정 크기의 메모리가 생성된다.
<br>
그리고 각 요소에 값이 있을 때, [n]같이 접근하여 값을 가져올 수 있는데, 이 값이 커질 경우 탐색하는 시간이 많이 소요된다.
<br>
<br>
배열에서 특정 값을 찾기 위해 탐색 알고리즘을 사용하면, 탐색하는 비용이 발생하며 값을 찾아야 한다.
<br>
이 경우 배열의 크기가 커질 수록 시간이 오래 걸리는 단점이 있다.
<br>
<br>
이러한 단점을 해결하기 위해 사용하는 것이 해시 테이블 알고리즘이다.
<br>
배열에 각각의 인덱스에 해시를 매핑하여 탐색하는 비용을 줄이고, 굉장히 빠르게 찾을 수 있다.
<br>
<br>
이렇게 극한의 성능이 요구되는 분야(예 금융)에서 해시 테이블 알고리즘을 사용하며, 빠른 알고리즘(예 이분 탐색)보다 더욱 좋은 효율을 낼 수 있다.
<br>
<br>
해시 테이블에서 데이터가 해시 함수를 거치면 아래 그림처럼 테이블 내의 주소(인덱스)로 변환된다.
<br>

![image](https://user-images.githubusercontent.com/87363461/206887309-54fa7a59-68d8-4ee5-92a5-f73e84eeca25.png)

<br>

위 그림과 같이 123817 이라는 데이터를 해싱 함수를 거쳐 얻은 테이블 내의 주소값은 3819이다.
<br>
이제 해당 테이블 안에 해당 주소에 데이터를 저장하고, 읽을 수 있게된다.

```
// 데이터 저장
Table[3819] = 123817;

// 데이터 읽기
printf("Table[3819]");    // 123817 출력
```

위 과정을 3가지 순서로 정리할 수 있으며, 아래 그림과 같은 순서로 동작하는 개념이다.

<br>

![image](https://user-images.githubusercontent.com/87363461/206887382-1306de68-9785-4041-87ba-f28715476419.png)

<br>

여기서 알 수 있는 해시 테이블의 중요 개념은 <b>데이터를 담을 테이블을 미리 크게 확보한 후 입력 받은 데이터를 해싱하여 테이블 내 주소를 계산하고 이 주소를 데이터에 담는 것</b>이다.
<br>
<br>

## 해시 함수(Hash Function)
해시 함수란 입력값에서 테이블 내의 주소를 계산하는 함수를 말한다.
<br>
<br>
해시 함수의 계산 법은 많은 종류가 있으나, 이 글에서는 자릿수 접기(Digits Folding) 방법의 예제에 관해 설명한다.

### 해시 함수 종류
해시 함수의 몇몇 예이며, 이 말고도 여러 함수가 존재한다.
<ul>
<li>나눗셈법 or 제산법(Division)</li>
<li>제곱법(Mid – Square)</li>
<li>숫자 분석법(Digit Analysis)</li>
<li>이동법(Shifting)</li>
<li>기수 변환법(Radix Conversion)</li>
<li>중첩법(Folding)</li>
<li>난수 생성법(Pseudo Random)</li>
</ul>

## 자릿수 접기(Digits Folding)
프로그래밍을 하다보면, 서로 다른 입력값에 대해 동일한 해시값을 반환할 가능성이 있다.
<br>
즉, 해시 테이블 내의 동일한 주소를 반환할 가능성이 높다는 얘기다.
<br>
<br>
이것을 충돌(Collision) 이라고 하는데, 똑같은 해시값이 아니더라도 해시 테이블 내 일부 지역의 주소들을 집중적으로 반환함으로써 데이터가 한 곳에 모이는 문제인 클러스터(Cluster)가 발생할 가능성이 높다.
<br>
<br>
이 자릿수 접기 방법을 이용하면 충돌이나 클러스터링 문제에 대해 문제를 일으킬 가능성을 줄일 수 있다.<br>
(충돌이나 클러스터링을 완벽하게 해결하는 알고리즘은 현재 없다..)
<br>
<br>
자릿수 접기는 숫자의 각 자리수를 더해 해시값을 만드는 방법이다.
<br>

예를 들어 7자리의 수인 8129335 값이 존재한다고 하자.
```
8129335
```

이 수의 각 자리수를 모두 더하면 새로운 값인 31이 나온다.

```
31 = 8 + 1 + 2 + 9 + 3 + 3 + 5
```

또 다른 방법으로, 8129335를 2자리씩 잘라서 더해보자.
```
148 = 81 + 29 + 33 + 5
```

이처럼 자릿수 접기 방법을 통하여 일정한 범위 내의 해시값을 얻는 것을 볼 수 있다.
<br>
10진수의 경우 모든 수는 각 자리마다 0 ~ 9 까지의 값을 가질 수 있으므로, 7자리에 대해 자릿수 접기 방법을 적용한다.
<br>
<br>
한 자리씩 접으면 최소 0부터 최대 63(9 + 9 + 9 + 9 + 9 + 9 + 9 총 7자리) 까지의 해시값을 얻을 수 있고,
<br>
두 자리씩 접으면 최소 0부터 최대 306(99 + 99 + 99 + 9 총 7자리)까지의 해시값을 얻을 수 있다.
<br>
<br>
자릿수 접기는 문자열을 키로 사용하는 해시 테이블에 특히 잘 어울리는 알고리즘이다.
<br>
문자열의 각 요소를 ASCII 코드 번호로 바꾸고, 이 값을을 각각 더해서 접으면 문자열을 깔끔하게 해시 테이블의 주소로 바꿀 수 있기 때문이다.

<br>

![image](https://user-images.githubusercontent.com/87363461/206887865-97d82c5c-e131-45dc-89b6-4871893dd798.png)

<br>
