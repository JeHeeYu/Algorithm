## 해시 테이블(Hash Table)

## 해시(Hash)
해시란 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(Mapping)한 값이다.
<br>
즉, 해시는 데이터를 입력받아 완전히 다른 모습의 데이터로 바꾸는 작업을 말한다.
<br>
<br>
해시를 이용하여 탐색 알고리즘인 해시 테이블 알고리즘, SHA, MD5 암호화 알고리즘, 데이터 축약 등과 같은 용도로 사용한다.
<br>


## 해시 테이블(Hash Table)
해시 테이블이란 쉽게 말해 데이터의 해시(Hash)값을 얻어 테이블 내의 주소로 사용하는 것이다.
<br>
테이블을 (Key, Value) 구조로 데이터를 저장하는 자료구조 중 하나로, 빠르게 데이터를 검색할 수 있는 것이 장점이다.
<br>
<br>
예를 들어 배열을 선언하면 메모리에 일정 크기의 메모리가 생성된다.
<br>
그리고 각 요소에 값이 있을 때, [n]같이 접근하여 값을 가져올 수 있는데, 이 값이 커질 경우 탐색하는 시간이 많이 소요된다.
<br>
<br>
배열에서 특정 값을 찾기 위해 탐색 알고리즘을 사용하면, 탐색하는 비용이 발생하며 값을 찾아야 한다.
<br>
이 경우 배열의 크기가 커질 수록 시간이 오래 걸리는 단점이 있다.
<br>
<br>
이러한 단점을 해결하기 위해 사용하는 것이 해시 테이블 알고리즘이다.
<br>
배열에 각각의 인덱스에 해시를 매핑하여 탐색하는 비용을 줄이고, 굉장히 빠르게 찾을 수 있다.
<br>
<br>
이렇게 극한의 성능이 요구되는 분야(예 금융)에서 해시 테이블 알고리즘을 사용하며, 빠른 알고리즘(예 이분 탐색)보다 더욱 좋은 효율을 낼 수 있다.
<br>
<br>
해시 테이블에서 데이터가 해시 함수를 거치면 아래 그림처럼 테이블 내의 주소(인덱스)로 변환된다.
<br>

![image](https://user-images.githubusercontent.com/87363461/206887309-54fa7a59-68d8-4ee5-92a5-f73e84eeca25.png)

<br>

위 그림과 같이 123817 이라는 데이터를 해싱 함수를 거쳐 얻은 테이블 내의 주소값은 3819이다.
<br>
이제 해당 테이블 안에 해당 주소에 데이터를 저장하고, 읽을 수 있게된다.

```
// 데이터 저장
Table[3819] = 123817;

// 데이터 읽기
printf("Table[3819]");    // 123817 출력
```

위 과정을 3가지 순서로 정리할 수 있으며, 아래 그림과 같은 순서로 동작하는 개념이다.

<br>

![image](https://user-images.githubusercontent.com/87363461/206887382-1306de68-9785-4041-87ba-f28715476419.png)

<br>

여기서 알 수 있는 해시 테이블의 중요 개념은 <b>데이터를 담을 테이블을 미리 크게 확보한 후 입력 받은 데이터를 해싱하여 테이블 내 주소를 계산하고 이 주소를 데이터에 담는 것</b>이다.
<br>
<br>

## 해시 함수(Hash Function)
해시 함수란 입력값에서 테이블 내의 주소를 계산하는 함수를 말한다.
<br>
<br>
해시 함수의 계산 법은 많은 종류가 있으나, 이 글에서는 자릿수 접기(Digits Folding) 방법의 예제에 관해 설명한다.

### 해시 함수 종류
해시 함수의 몇몇 예이며, 이 말고도 여러 함수가 존재한다.
<ul>
<li>나눗셈법 or 제산법(Division)</li>
<li>제곱법(Mid – Square)</li>
<li>숫자 분석법(Digit Analysis)</li>
<li>이동법(Shifting)</li>
<li>기수 변환법(Radix Conversion)</li>
<li>중첩법(Folding)</li>
<li>난수 생성법(Pseudo Random)</li>
</ul>

## 자릿수 접기(Digits Folding)
프로그래밍을 하다보면, 서로 다른 입력값에 대해 동일한 해시값을 반환할 가능성이 있다.
<br>
즉, 해시 테이블 내의 동일한 주소를 반환할 가능성이 높다는 얘기다.
<br>
<br>
이것을 충돌(Collision) 이라고 하는데, 똑같은 해시값이 아니더라도 해시 테이블 내 일부 지역의 주소들을 집중적으로 반환함으로써 데이터가 한 곳에 모이는 문제인 클러스터(Cluster)가 발생할 가능성이 높다.
<br>
<br>
이 자릿수 접기 방법을 이용하면 충돌이나 클러스터링 문제에 대해 문제를 일으킬 가능성을 줄일 수 있다.<br>
(충돌이나 클러스터링을 완벽하게 해결하는 알고리즘은 현재 없다..)
<br>
<br>
자릿수 접기는 숫자의 각 자리수를 더해 해시값을 만드는 방법이다.
<br>

예를 들어 7자리의 수인 8129335 값이 존재한다고 하자.
```
8129335
```

이 수의 각 자리수를 모두 더하면 새로운 값인 31이 나온다.

```
31 = 8 + 1 + 2 + 9 + 3 + 3 + 5
```

또 다른 방법으로, 8129335를 2자리씩 잘라서 더해보자.
```
148 = 81 + 29 + 33 + 5
```

이처럼 자릿수 접기 방법을 통하여 일정한 범위 내의 해시값을 얻는 것을 볼 수 있다.
<br>
10진수의 경우 모든 수는 각 자리마다 0 ~ 9 까지의 값을 가질 수 있으므로, 7자리에 대해 자릿수 접기 방법을 적용한다.
<br>
<br>
한 자리씩 접으면 최소 0부터 최대 63(9 + 9 + 9 + 9 + 9 + 9 + 9 총 7자리) 까지의 해시값을 얻을 수 있고,
<br>
두 자리씩 접으면 최소 0부터 최대 306(99 + 99 + 99 + 9 총 7자리)까지의 해시값을 얻을 수 있다.
<br>
<br>
자릿수 접기는 문자열을 키로 사용하는 해시 테이블에 특히 잘 어울리는 알고리즘이다.
<br>
문자열의 각 요소를 ASCII 코드 번호로 바꾸고, 이 값을을 각각 더해서 접으면 문자열을 깔끔하게 해시 테이블의 주소로 바꿀 수 있기 때문이다.

<br>

![image](https://user-images.githubusercontent.com/87363461/206887865-97d82c5c-e131-45dc-89b6-4871893dd798.png)

<br>

## 충돌 해결 기법
충돌이란 해시 함수가 서로 다른 입력값에 대해 동일한 해시 테이블 주소를 반환하는 것을 말
<br>
자릿수 접기 알고리즘을 포함한 모든 해시 함수들은 충돌을 피할 수 없지만, 체이닝 기법을 통해 조취를 취하고 있다.

<br>
<br>

해시 테이블의 충돌을 해결하는 방법은 크게 두 가지로, 개방 해싱(Open Hashing)과 폐쇄 해싱(Closed Hashing) 방법이 있다.

<ul>
<li>개방 해싱 : 해시 테이블의 주스ㅗ 바깥에 새로운 공간을 할당하여 문제를 해결</li>
<li>주어진 해시 테이블의 공간 안에서 문제를 해결</li>
</ul>

## 개방 해싱을 이용한 체이닝(Chaining)
체이닝이란 해시 함수가 서로 다른 키에 대해 같은 주소값을 반환해서 충돌이 발생하면, 각 데이터를 해당 주소에 있는 링크드 리스트로 삽입하여 문제를 해결하는 기법을 말한다.
<br>
<br>
아래 그림이 체이닝의 예로, 체이닝 기반 해시 테이블은 데이터 대신 링크드 리스트에 대한 포인터를 관리한다.
<br>
이후 데이터는 해시 테이블의 각 요소가 가리키는 링크드 리스트에 저장된다.
<br>
<br>
이렇게 해시 테이블 외부에 데이터를 저장하는 체이닝은 개방 해싱 알고리즘에 해당한다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/206946324-93b2da07-e9ce-4e03-9820-c659f09b4e93.PNG)

<br>

체이닝을 이용하여 해시 테이블 알고리즘을 설계할 때 중요한 부분이 해시 테이블에 삽입하고 탐색, 삭제하는 연산 과정이다.
<br>

<ul>
<li>탐색 연산 : 이미 발생한 충돌을 고려하여 설계</li>
<li>삭제 연산 : 이미 발생한 충돌을 고려하여 설계</li>
<li>삽입 연산 : 앞으로 발생할 충돌을 고려해서 설계</li>
</ul>

## 체이닝 기반 해시테이블 구조체
해시 테이블은 키와 밸류 (Key : Value)가 한 쌍인 자료구조로, 키와 밸류를 별도로 관리하여야 한다.
```
// key와 value 값을 갖고 있는 노드
typedef struct _Node
{
    char* key;
    char* value;
} Node;

// 해시 테이블
typedef struct _HashTable
{
    int tableSize;
    Node* table;
} HashTable;
```

## 탐색 연산
체이닝 기반의 해시 테이블은 3가지의 순서로 탐색을 진행한다.

<ol>
<li>찾고자 하는 목표값을 해싱하여 링크드 리스트가 저장된 주소를 찾음</li>
<li>찾은 주소를 이용해 해시 테이블에 저장된 링크드 리스트에 대한 포인터 생성</li>
<li>링크드 리스트의 앞에서부터 뒤까지 차례대로 이동하여 목표값이 저장되어 있는지 비교하여 목표값과 링크드 리스트 내 노드값이 일치하면 해당 노드의 주소 반환</li>
</ol>

