## 우선순위 큐(Priority Queue)
우선순위 큐란 큐의 속성을 지니고 있지만, 우선순위에 따라 출력 순서를 결정한다는 점이 다르다.
<br>
우선순위 큐는 데이터의 삽입(Enqueue)과 제거(Dequeue)에 우선순위 속성을 갖는 자료구조이다.
<br>
<br>
우선순위 큐와 보통 큐의 차이는 삽입과 제거 연산이 어떤 동작으로 이루어지는가에 따라 달라진다.
<br>
보통 큐는 먼저 들어온 요소가 먼저 나가는 FIFO(First-In First-Out) 구조이지만, 
<br>
우선순위 큐는 우선순위를 부여하여 큐에 삽입하고 가장 높은 우선순위를 가진 요소부터 빠져 나오게 한다.
<br>
<br>
우선순위의 기준은 정해져있는 것이 아닌, 프로그래머가 직접 정하는 것이다.
<br>
<br>
예를 들어, 여러 데이터 중 값이 높은 데이터가 우선적으로 빠져나가야 하는 구조가 있을 것이고, 반대 구조도 있을 것이다.
<br>
그래서 낮은 값을 가진 데이터를 우선순위를 높게 주고, 낮은 데이터부터 빠져 나가게 할 수도 있다.

## 우선순위 큐의 삽입
먼저 아래와 같은 큐 구조가 있다.
<br>
유선순위 큐의 각 요소는 우선순위를 가지고, 이들 요소의 우선순위 오름차순으로 연결된다.
<br>
<br>
이 예제에서는 낮은 값의 데이터들이 높은 우선순위를 가진다.

<br>

![image](https://user-images.githubusercontent.com/87363461/205622036-8b0b40d3-f274-486e-bc49-ee65fa08165d.png)

<br>

위 큐에서 20의 값을 넣는 과정을 살펴보면, 먼저 첫 요소부터 순서차적으로 우선순위를 비교한다.
<br>
20은 2와 17보다 크고 22보다 작으므로 17과 22사이에 삽입되어야 한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205622194-720b2a53-74a4-4021-849f-5e795c0a9c57.png)

<br>

## 우선순위 큐의 제거
우선순위 큐의 제거 연산은 가장 앞 요소인 전단만 제거하면 되므로, 간단하다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205622500-7c799cb8-16d9-403b-a250-c606f2d127f9.png)

<br>

## 힙을 이용한 우선순위 큐 구현
우선순위 큐를 구현하기 위해 힙을 이용한다.
<br>
여기서 힙(Heap)은 자유 저장소의 힙이 아닌, 힙 순서 속성(Heap Order Priority)을 만족하는 완전 이진트리를 말한다.
<br>
<br>
완전 이진 트리란 최고 깊이(잎 노드) 노드들을 제외한 나머지 노드들이 모두 채워져 있는 이진 트리를 말한다.
<br>
아래 트리의 구조가 완전 이진 트리 구조이며, 최고 깊이 노드들이 모두 채워져 있지 않은 것을 볼 수 있다.

<br>

![image](https://user-images.githubusercontent.com/87363461/205623208-ac4d3312-c8d9-470c-911b-da2b21cbbc8b.png)

<br>

여기서 중요한 부분은 <b>힙 순서 속성</b>이며, 이 속성을 이해해야 우선순위 큐를 구현할 수 있다.
<br>
힙 순서 속성이란 쉽게 말해 <b>트리 내의 모든 노드가 부모 노드보다 커야한다</b> 라는 규칙이다.
<br>
<br>
여기서 뿌리 노드는 맨 위 루트 노드이니 제외한다.
<br>
<br>
아래 트리 구조가 힙 순서를 만족하는 이진트리로, 힙의 예이다.
<br>
노드 값을 보면 깊이가 깊어질 수록 값이 더 커지는 것을 볼 수 있다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205623506-0cb07bab-c641-4798-be26-bc8c5e36a9dc.png)

<br>

힙의 가장 중요한 점은 <b>힙에서 가장 작은 데이터를 갖는 노드는 뿌리 노드</b>라는 점이다.
<br>
<br>
이 점에 따라 힙에 사용되는 연산은 2가지 뿐이며, 하나는 새 노드를 삽입하는 연산, 그리고 뿌리노드를 없애는 최솟값 삭제 연산이다.

## 힙의 삽입 연산
힙의 삽입 연산은 3단계를 거쳐 이루어진다.

<ol>
  <li>힙의 최고 깊이 가장 우측에 새 노드를 추가한다. 이때 힙은 완전 이진 트리를 유지하여야 한다.</li>
  <li>삽입한 노드를 부모 노드와 비교하여 삽입한 노드가 부모 노드보다 크면 제 위치에 삽입된 것으로 종료한다.<br>
  (만약 이때 반대로 부모 노드보다 작을 경우 다음 단계를 진행한다.)</li>
  <li>삽입한 노드가 부모 노드보다 작으면 부모 노드와 삽입한 위치를 서로 바꾸고, 다시 2번의 단계로 돌아가 진행한다.</li>
</ol>

삽입 연산은 새로 삽입한 노드가 힙 순서 속성을 만족할 때까지 그 노드를 부모 노드와 교환하는 것이 핵심이다.

### 힙 노드 삽입 예제
아래와 같은 힙이 있으며, 이 힙에 7을 삽입하는 예제이다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205625141-18531b97-2693-49fc-ab7e-ef5e26849a94.png)

<br>

새 노드 7을 힙의 가장 깊은 곳에 추가한다.
<br>
이때 완전 이진트리가 깨지면 안되므로, 노드 37의 오른쪽 자식에 추가한다.
<br>
<br>
그리고 추가한 노드(7)와 부모 노드(37)을 비교한다.
<br>
7은 37보다 작으므로 새로 추가한 노드와 부모 노드 자리를 교환(3번 과정)한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205625385-13c8df2c-db38-4073-aaba-0eb1974977d8.png)

<br>

7이 37과 교환되어 한 단계 올라갔으며, 다시 부모 노드와 비교한다.
<br>
추가한 노드(7)와 부모 노드(8)간 비교 시 추가한 노드가 값이 작으므로 다시 교환을 수행한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205625550-ddb7c36e-45bc-4ffa-a42e-bea1265be178.png)

<br>
