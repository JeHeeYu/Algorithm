## 요약
### 시간 복잡도 : 삽입 및 삭제 연산 𝑂(𝑙𝑜𝑔𝑁)

<ul>
  <li>큐의 속성을 갖고 있으면서 우선순위로 출력 순서를 결정함</li>
  <li>완전 이진 트리 형태의 힙 구조를 이용하여 구현</li>
  <li>힙 순서 속성(트리 내의 모든 노드가 부모 노드보다 커야함)의 규칙을 지켜야 함</li>
  <li>힙에 사용되는 연산은 2가지로 하나는 새 노드를 삽입하는 연산, 그리고 뿌리노드를 없애는 최솟값 삭제 연산 두 가지임</li>
</ul>

## 우선순위 큐(Priority Queue)
우선순위 큐란 큐의 속성을 지니고 있지만, 우선순위에 따라 출력 순서를 결정한다는 점이 다르다.
<br>
우선순위 큐는 데이터의 삽입(Enqueue)과 제거(Dequeue)에 우선순위 속성을 갖는 자료구조이다.
<br>
<br>
우선순위 큐와 보통 큐의 차이는 삽입과 제거 연산이 어떤 동작으로 이루어지는가에 따라 달라진다.
<br>
보통 큐는 먼저 들어온 요소가 먼저 나가는 FIFO(First-In First-Out) 구조이지만, 
<br>
우선순위 큐는 우선순위를 부여하여 큐에 삽입하고 가장 높은 우선순위를 가진 요소부터 빠져 나오게 한다.
<br>
<br>
우선순위의 기준은 정해져있는 것이 아닌, 프로그래머가 직접 정하는 것이다.
<br>
<br>
예를 들어, 여러 데이터 중 값이 높은 데이터가 우선적으로 빠져나가야 하는 구조가 있을 것이고, 반대 구조도 있을 것이다.
<br>
그래서 낮은 값을 가진 데이터를 우선순위를 높게 주고, 낮은 데이터부터 빠져 나가게 할 수도 있다.

## 우선순위 큐의 삽입
먼저 아래와 같은 큐 구조가 있다.
<br>
유선순위 큐의 각 요소는 우선순위를 가지고, 이들 요소의 우선순위 오름차순으로 연결된다.
<br>
<br>
이 예제에서는 낮은 값의 데이터들이 높은 우선순위를 가진다.

<br>

![image](https://user-images.githubusercontent.com/87363461/205622036-8b0b40d3-f274-486e-bc49-ee65fa08165d.png)

<br>

위 큐에서 20의 값을 넣는 과정을 살펴보면, 먼저 첫 요소부터 순서차적으로 우선순위를 비교한다.
<br>
20은 2와 17보다 크고 22보다 작으므로 17과 22사이에 삽입되어야 한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205622194-720b2a53-74a4-4021-849f-5e795c0a9c57.png)

<br>

## 우선순위 큐의 제거
우선순위 큐의 제거 연산은 가장 앞 요소인 전단만 제거하면 되므로, 간단하다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205622500-7c799cb8-16d9-403b-a250-c606f2d127f9.png)

<br>

## 힙을 이용한 우선순위 큐 구현 방법
우선순위 큐를 구현하기 위해 힙을 이용한다.
<br>
여기서 힙(Heap)은 자유 저장소의 힙이 아닌, 힙 순서 속성(Heap Order Priority)을 만족하는 완전 이진트리를 말한다.
<br>
<br>
완전 이진 트리란 최고 깊이(잎 노드) 노드들을 제외한 나머지 노드들이 모두 채워져 있는 이진 트리를 말한다.
<br>
아래 트리의 구조가 완전 이진 트리 구조이며, 최고 깊이 노드들이 모두 채워져 있지 않은 것을 볼 수 있다.

<br>

![image](https://user-images.githubusercontent.com/87363461/205623208-ac4d3312-c8d9-470c-911b-da2b21cbbc8b.png)

<br>

여기서 중요한 부분은 <b>힙 순서 속성</b>이며, 이 속성을 이해해야 우선순위 큐를 구현할 수 있다.
<br>
힙 순서 속성이란 쉽게 말해 <b>트리 내의 모든 노드가 부모 노드보다 커야한다</b> 라는 규칙이다.
<br>
<br>
여기서 뿌리 노드는 맨 위 루트 노드이니 제외한다.
<br>
<br>
아래 트리 구조가 힙 순서를 만족하는 이진트리로, 힙의 예이다.
<br>
노드 값을 보면 깊이가 깊어질 수록 값이 더 커지는 것을 볼 수 있다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205623506-0cb07bab-c641-4798-be26-bc8c5e36a9dc.png)

<br>

힙의 가장 중요한 점은 <b>힙에서 가장 작은 데이터를 갖는 노드는 뿌리 노드</b>라는 점이다.
<br>
<br>
이 점에 따라 힙에 사용되는 연산은 2가지 뿐이며, 하나는 새 노드를 삽입하는 연산, 그리고 뿌리노드를 없애는 최솟값 삭제 연산이다.

## 힙의 삽입 연산
힙의 삽입 연산은 3단계를 거쳐 이루어진다.

<ol>
  <li>힙의 최고 깊이 가장 우측에 새 노드를 추가한다. 이때 힙은 완전 이진 트리를 유지하여야 한다.</li>
  <li>삽입한 노드를 부모 노드와 비교하여 삽입한 노드가 부모 노드보다 크면 제 위치에 삽입된 것으로 종료한다.<br>
  (만약 이때 반대로 부모 노드보다 작을 경우 다음 단계를 진행한다.)</li>
  <li>삽입한 노드가 부모 노드보다 작으면 부모 노드와 삽입한 위치를 서로 바꾸고, 다시 2번의 단계로 돌아가 진행한다.</li>
</ol>

삽입 연산은 새로 삽입한 노드가 힙 순서 속성을 만족할 때까지 그 노드를 부모 노드와 교환하는 것이 핵심이다.

### 힙 노드 삽입 예제
아래와 같은 힙이 있으며, 이 힙에 7을 삽입하는 예제이다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205625141-18531b97-2693-49fc-ab7e-ef5e26849a94.png)

<br>

새 노드 7을 힙의 가장 깊은 곳에 추가한다.
<br>
이때 완전 이진트리가 깨지면 안되므로, 노드 37의 오른쪽 자식에 추가한다.
<br>
<br>
그리고 추가한 노드(7)와 부모 노드(37)을 비교한다.
<br>
7은 37보다 작으므로 새로 추가한 노드와 부모 노드 자리를 교환(3번 과정)한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205625385-13c8df2c-db38-4073-aaba-0eb1974977d8.png)

<br>

7이 37과 교환되어 한 단계 올라갔으며, 다시 부모 노드와 비교한다.
<br>
추가한 노드(7)와 부모 노드(8)간 비교 시 추가한 노드가 값이 작으므로 다시 교환을 수행한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/205625550-ddb7c36e-45bc-4ffa-a42e-bea1265be178.png)

<br>

다시 7이 한 단계 올라왔고, 비교할 노드가 뿌리 노드밖에 남지 않았다.
<br>
뿌리 노드(2)는 7보다 작으므로 힙 순서 속성을 위반하지 않는다.
<br>
이것으로 삽입 연산이 완성된 것이다.

<br>

## 힙 최솟값 노드 삭제 연산
힙에서의 최솟값 삭제는 곧 뿌리 노드를 삭제한다는 말과 같은 의미이다.
<br>
힙 구조에서는 뿌리 노드의 삭제는 큰 문제가 아니며 삭제 후 힙 순서 속성을 유지하는 것이 문제이다.<br>
<br>
예를 들어, 아래와 같은 구조에서 뿌리 노드를 삭제하고, 힙 순서 속성을 유지하는 과정이다.

<br>

![image](https://user-images.githubusercontent.com/87363461/206838834-82921f32-245e-453c-8f16-46c59ee203ac.png)


<br>

<ol>
<li>힙의 최고 깊이 가장 우측에 있던 노드를 뿌리 노드로 옮김<br>(이때 힙 순서 속성 파괴)</li>
<li>옮겨온 노드의 양쪽 자식을 비교하여 작은쪽 자식과 위치 교환<br>
(힙 순서 속성을 지키려면 부모 노드는 양쪽 자식보다 작은 값을 가져야 함)</li>
<li>옮겨온 노드가 더 이상 자식이 없는 잎 노드로 되거나 양쪽 자식보다 작은 값을 갖는 경우 삭제 연산 종료<br>
(그렇지 않은 경우 2번 재 반복)</li>
</ol>

아래 과정은 위 과정을 상세 과정으로 설명하는 내용이다.
<br>
<br>
먼저 힙에서 최솟값 노드(뿌리)를 삭제한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/206838897-5c295074-4291-4b20-8620-1d95a26004de.png)


<br>
힙의 최고깊이 가장 우측 노드를 삭제된 뿌리 노드가 있던 곳으로 옮긴다.
<br>
그 후 힙 순서 속성의 위반 여부를 살펴야 한다.
<br>
<br>
힙 순서 속성에 의하면 부모 노드 값 < 자식 노드 값을 가져야 하는데, 뿌리 노드(37)이 왼쪽 자식 노드(7)보다 크므로 힙 순서 속성을 위반한다.
<br>
그래서 뿌리 노드는 양쪽 자식 중 작은 값을 가진 노드와 교환한다. (왼쪽 자식 노드 <-> 뿌리 노드)
<br>

![image](https://user-images.githubusercontent.com/87363461/206838935-e7a4a014-2012-4eb2-b521-6e356fb49c6c.png)


<br>

뿌리 노드와 왼쪽 자식 노드의 값 교환으로 인해 37이 한 단계 내려온 것을 볼 수 있다.
<br>
다시 힙 순서 속성의 위반 여부를 확인한다.
<br>
<br>
37이 양쪽 자식(13, 8) 보다 크므로 더 작은 값인 오른쪽 자식 노드(8)와 서로 노드를 교환한다.
<br>

![image](https://user-images.githubusercontent.com/87363461/206838972-926d1cf1-e334-4615-8d11-a3cb5bde6bac.png)


<br>

다시 37이 한 단계 내려왔으며, 또 다시 힙 순서 속성 위반 여부를 확인한다.
<br>
37 노드의 자식 노드의 값을 확인 하였더니 88로, 더 이상 힙 순서 속성을 위반하지 않는다.
<br>
이것으로 삭제 연산이 완료된 것이다.
<br>

![image](https://user-images.githubusercontent.com/87363461/206839022-a1bf2be5-21bf-4e57-adce-4ee0ffd3ee8f.png)



### [예제 코드](https://github.com/JeHeeYu/Algorithm/blob/main/Queue/Priority%20Queue/PriorityQueue.c)

### 실행 결과
```
큐에 남아 있는 작업의 수 : 6
작업명 : 밥먹기 (우선순위 : 12)
작업명 : 코딩 (우선순위 : 34)
작업명 : 디버깅 (우선순위 : 35)
작업명 : 문서작성 (우선순위 : 45)
작업명 : 이닦기 (우선순위 : 66)
작업명 : 커피타기 (우선순위 : 87)

```
