## 원형 큐(Circular Queue)
원형 큐란 기본 선형 큐의 FIFO(First-In First-Out) 특성을 갖고 있는 큐에서 전단과 후단이 연결되어 있는 큐 구조를 말한다.
<br>
일반 큐 구조에서 제거 연산이 일어날 경우 데이터의 제거가 일어날 경우가 문제인데, 제거할 때 나머지 요소들을 앞으로 한 칸씩 옮겨야 한다. 이때 드는 비용이 상당히 만이 들어서 문제가 발생한다.
<br>
<br>
만약 큐 용량이 100일 경우, 제거를 한번 했는데도 99번의 이동 작업을 수행해야 하여 많이 비효율 적이다.
<br>
<br>
이 문제를 해결하기 위해 원형 큐를 사용하는데, 전단을 가리키는 변수를 도입해서 배열 내 요소를 옮기는 대신 전단의 위치만 변경하여 사용한다.
<br>
<br>
이와 함께 후단을 가리키는 변수도 생성해서 삽입이 일어날 때마다 후단의 위치를 변경한다.
<br>
이때 후단을 가리키는 변수는 실제 후단의 위치 + 1 한 값을 담아야 한다.
<br>
<br>
아래 큐가 바로 원형큐를 나타내는 큐다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207783644-8e5f33f2-075d-4ed8-a315-b8353d320bba.PNG)

<br>
이 큐를 배열로 생각해보자.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207783985-1e734819-57f0-459d-a0b9-3ac0ea197107.PNG)

<br>

배열의 마지막 요소가 후단이었을 때 8을 삽입했고, 이로 인해 배열의 첫 번째 요소가 후단이 된다.
<br>
이 상태에서다시9를 삽입, 배열의 두 번째 요소가 후단이 되었다.
<br>
<br>
여기서 삽입이 이루어질 때마다 후단이 뒤로 후퇴하다가 전단을 만나면 큐는 가득 찬 상태가 된다.
<br>
<br>
큐가 가득 찼을 경우 삭제가 일어나지 않는 이상 추가적인 삽입은 불가능하다.
<br>
<br>
아래 그림이 위 설명을 표현한 그림이다.
<br>

## 공백 상태와 포화 상태
원형 큐가 제대로 동작하기 위해 큐가 공백 상태인지, 포화 상태인지 체크해야 한다.
<br>
공백 상태와 포화 상태를 체크하는 이유는 바로 전단과 후단이 같은 위치에 있어 만나기 때문이다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207784387-2c98b94e-c2f3-4425-9e16-0d1faa7fbeff.PNG)

<br>

이 문제를 간단하게 해결하기 위해서 일반적으로 큐를 생성할 때 실제 용량보다 1만큼 더 크게 만든다.
<br>
그리고 전단과 후단(실제로는 후단) 사이를 비워두는 것이다.
<br>
<br>
이렇게 하면 큐가 공백 상태일 때 전단과 후단이 같은 곳을 가리키고, 큐가 포화 상태일 경우 후단이 전보다 1값이 작으므로 상태 구분이 용이해진다.
<br>

![캡처](https://user-images.githubusercontent.com/87363461/207784536-cd5a0277-951c-4292-b0c9-8caef504dc4a.PNG)

<br>

## 원형 큐 구현하기
배열을 기반으로 구현한 원형 큐 예제이다.

## 원형 큐 구조체
```
typedef struct _Node
{
    int data;
} Node;

typedef struct _CircleQueue
{
    int capacity; // 큐의 용량
    int front;    // 전단 위치
    int rear;     // 후단 위치
    
    Node* node;   // 요소 데이터
} CircularQueue;
```
여기서 주의해야 할 점은 rear의 크기는 실제 후단 + 1의 값을 갖는다는 점이다.

## 원형 큐 생성
```
```
