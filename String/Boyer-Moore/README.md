## 요약
### 시간 복잡도 평균 : O(n / m) / 최악 : O(n)

<ul>
  <li>검색하고자 하는 패턴의 마지막 문자부터 앞쪽으로 검사를 진행</li>
  <li>일치하지 않는 문자가 있을 경우 Skip 표에 따라 패턴을 옮겨 가면서 검사</li>
  <li>각각의 문자를 만났을 때 패턴을 옮길 크기를 저장할 표를 만들어야 함</li>
  <li>문자열의 커서는 앞에서 뒤로, 패턴의 커서는 뒤에서 앞으로 역방향으로 검사</li>
</ul>


## Boyer-Moore 알고리즘이란
Boyer-Moore 알고리즘이란 검색하고자 하는 패턴의 마지막 문자부터 앞쪽으로 검사를 진행하면서 일치하지 않는 
<br>
문자가 있으면 미리 준비한 표에 따라 패턴을 옮길 크기를 정하는 고리즘이다.
<br>
<br>
Booyer-Moore 법은 Brute-Froce나 KMP 보다 효율이 더 우수하기 때문에 널리 사용되는 문자열 검색 알고리즘이다.
<br>
R.S Boyer, J.s Moore가 만든 알고리즘으로 그의 이름을 따 만들어졌다.
<br>
<br>
아래 예제는 텍스트 "ABCXDEZCABACABAC"에서 패턴 "ABAC"를 검색하는 예제이다.
<br>
<br>
<img src="https://user-images.githubusercontent.com/87363461/202836761-66fa3086-534b-496e-a993-f45bad404de6.JPG" width="500" height="200">
<br>
<br>
먼저 텍스트와 검색할 패턴의 첫 번째 문자를 겹쳐보고 검색할 패턴의 마지막 문자 'C'를 검사한다.
<br>
텍스트의 'X'는 패턴에 없으므로, 이 문자는 패턴에 아예 없는 문자이기 때문에 패턴을 한 칸씩 뒤로 옮겨도 일치하지 않는다.
<br>
<br>
이와 같이 텍스트 안에서 패턴에 들어 있지 않은 문자를 찾으면 해당 위치까지의 문자는 건너 뛸 수 있다.
<br>
<br>
만약 패턴을 옮기는 과정을 생략하면 아래와 같은 상태가 된다.
<br>
이 상태는 패턴의 마지막 문자 'C'와 텍스트의 'C'가 일치하기 때문에 패턴을 1칸 옮길 수 있다.
<br>
<br>
<img src="https://user-images.githubusercontent.com/87363461/202837392-bfb24c86-34eb-4ac9-9210-fa1904f63344.JPG" width="400" height="200">
<br>
<br>
패턴의 마지막 문자 'C'는 텍스트와 일치하고 있다. 다시 'C'의 이전 문자 'A'를 검사하면 'Z'와 다른 문자임을 알 수 있다.
<br>
<br>
<img src="https://user-images.githubusercontent.com/87363461/202837624-100f780c-12d9-4d48-bf5a-613c3a50f62e.JPG" width="500" height="200">
<br>
<br>
패턴을 1칸, 2칸 옮기더라도 텍스트의 'Z' 문자는 검사할 패턴의 문자열에 존재하지 않는 것을 확인할 수 있다.
<br>
<br>
이러면 또 다시 검색할 패턴을 한꺼번에 3칸 옮겨 다시 검사를 시작한다.
<br>
<br>
<img src="https://user-images.githubusercontent.com/87363461/202837533-c16a7ec9-bc54-443a-9f61-ebb065cbf317.JPG" width="600" height="200">
<br>
<br>
이렇게 <b>패턴의 길이를 n이라고 할 때 현재 검사하고 있는 텍스트의 문자 위치로부터 다음에 검사할 패턴의 마지막 문자 위치가 n만큼 떨어질 수 있도록 패턴을 옮기면 된다.</b>
이것이 Boyer-Moore 알고리즘을 적용하여 문자열을 검색하는 방법이다.
<br>
<br>
이렇게 옮긴 다음 다시 검사를 시작해도 텍스트의 'A'와 패턴의 마지막 문자 'C'를 비교한다.
<br>
하지만 문자 'A'는 패턴의 1, 3번째 인덱스에 들어있다.
<br>
이런 경우 두 번째 작업과 같이 패턴의 뒤쪽에 위치한 'A'가 텍스트와 위 아래로 겹치도록 패턴을 1칸만 옮긴다.
<br>
<br>
패턴의 검색은 문자 뒤에서부터 검색해야 하므로 만약 네 번째 작업과 같이 패턴을 3칸 옮기면 안된다.
<br>
<br>
결론적으로 패턴을 1칸만 옮기게 되면 아래 그림과 같은 상태가 되고, 패턴의 마지막 위치에서 순서대료 문자를 비교하면 모두 일치하므로 검색 성공이다.
<br>
<br>
<img src="https://user-images.githubusercontent.com/87363461/202837731-dc5ff2a2-e78a-43dd-a42a-6524f72c67bb.JPG" width="400" height="200">
<br>
<br>

## Skip 표 만들기
Boyer-Moore 알고리즘도 KMP 알고리즘과 같이 각각의 문자를 만났을 때 패턴을 옮길 크기를 저장할 표를 만들어야 한다.
<br>
이 표를 Skip 표(건너뛰기 표)라고 한다.
<br>
<br>
패턴 문자열의 크기가 n일 때 옮길 크기는 아래와 같은 방법으로 결정한다.

### 패턴에 들어 있지 않은 문자를 만난 경우
<ol>
<li>패턴을 옮길 크기는 n이며, 마지막 문자부터 처음 문자까지 하나하나 비교한다.</li>
<li>텍스트의 문자('X')와 검색할 패턴의 문자("ABAC")가 일치하지 않으므로 패턴 4칸을 뒤로 옮긴다.</li>
</ol>

### 패턴에 들어 있는 문자를 만난 경우
<ol>
<li>마지막에 나오는 위치의 인덱스가 k이면 패턴을 옮길 크기는 n - k - 1이다.</li>
<li>검색할 패턴의 뒷 문자부터 일치하는 문자일 때까지 검사하여 마지막 인덱스를 기준으로 패턴을 옮긴다.</li>
<li>같은 문자가 패턴 안에 중복해서 들어있지 않다면(예를 들어 "ABAC" 에서 C는 1개만 존재) 패턴을 옮길 크기는 N이다.</li>
</ol>

아래 표는 표 작성 규칙에 의해 만든 표다.
<br>
<br>
<img src="https://user-images.githubusercontent.com/87363461/202837922-1558adc7-4809-4191-acd8-4a5e971c8074.JPG" width="700" height="200">
<br>
<br>
